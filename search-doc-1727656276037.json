[{"title":"GlobalUpdates","type":0,"sectionRef":"#","url":"/DataKeep/api/GlobalUpdates","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#types","content":" "},{"title":"GlobalId​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalId","content":"&lt;/&gt; type GlobalId = number Used to identify a global update "},{"title":"Functions​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#functions","content":" "},{"title":"AddGlobalUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#AddGlobalUpdate","content":"&lt;/&gt; GlobalUpdates:AddGlobalUpdate(globalData: {}) → Promise&lt;GlobalId&gt; Adds a global update to the Keep globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end)   "},{"title":"GetActiveUpdates​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GetActiveUpdates","content":"&lt;/&gt; GlobalUpdates:GetActiveUpdates() → {GlobalUpdate} Returns all active global updates local updates = globalUpdates:GetActiveUpdates() for _, update in updates do print(&quot;ActiveUpdate data:&quot;, update.Data) end   "},{"title":"RemoveActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#RemoveActiveUpdate","content":"&lt;/&gt; GlobalUpdates:RemoveActiveUpdate(updateId: GlobalId) → Promise&lt;void&gt; Removes an active global update local updates = globalUpdates:GetActiveUpdates() for _, update in updates do globalUpdates:RemoveActiveUpdate(update.ID):andThen(function() print(&quot;Removed Global Update!&quot;) end) end   "},{"title":"ChangeActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#ChangeActiveUpdate","content":"&lt;/&gt; GlobalUpdates:ChangeActiveUpdate( updateId: GlobalId, globalData: {} ) → Promise&lt;void&gt; Change an active global update's data to the new data. Useful for stacking updates to save space for Keeps that maybe receiving lots of globals. Ex. a content creator receiving gifts "},{"title":"Installation","type":0,"sectionRef":"#","url":"/DataKeep/docs/Installation","content":"","keywords":""},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#manual","content":"Install through the rbxm file in the releases tab. "},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#wally","content":"Download the module through Wally by adding this package! "},{"title":"Git Submodule​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#git-submodule","content":"Add this Repository as a git submodule. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/DataKeep/docs/intro","content":"","keywords":""},{"title":"What is DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#what-is-datakeep","content":"DataKeep is a module that loads and autosaves to datastores. A Keep Datastore (Holds datastore saving information &amp; methods) automatically saves itself and cleans up for you. "},{"title":"Why DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#why-datakeep","content":"No getter/setter functions, allows ability to write your own wrapper interfaceSession Locking, prevents other servers from editing directly to prevent duplication exploits or overwriting data lossGlobalUpdates to communicate to offline KeepsSimilar API to previous data ModuleScript ProfileService allowing easy to pick upPromised base for control over exactly when things completeActively maintained, and accepting contributions "},{"title":"Ready to get started?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#ready-to-get-started","content":"InstallationAPI Documentation "},{"title":"Developer Products","type":0,"sectionRef":"#","url":"/DataKeep/docs/DevProducts","content":"Developer Products The following example shows how you would handle developer product purchases: -- DevProducts.luau local DataKeep = require(path_to_datakeep) local devProducts = { [product_id_here] = function(player: Player, keep: DataKeep.Keep) keep.Data.Coins += 100 print(`{player.Name} purchased some coins!`) end, } return devProducts -- SetProcessReceipt.luau local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;) local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local DevProducts = require(path_to_devproducts) local purchaseHistoryLimit = 50 local function setProcessReceipt(store: DataKeep.Store, keyPrefix: string) local function processReceipt(receiptInfo): Enum.ProductPurchaseDecision local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end local isLoaded, keep = store:LoadKeep(keyPrefix .. player.UserId):await() if not isLoaded then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep:IsActive() then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep.Data.PurchaseHistory then keep.Data.PurchaseHistory = {} end if table.find(keep.Data.PurchaseHistory, receiptInfo.PurchaseId) then -- the purchase has been added to the player's data, but it might not have saved yet local success = keep:Save():await() if success then return Enum.ProductPurchaseDecision.PurchaseGranted else return Enum.ProductPurchaseDecision.NotProcessedYet end end -- remove purchaseIds which are beyond the limit while #keep.Data.PurchaseHistory &gt;= purchaseHistoryLimit do table.remove(keep.Data.PurchaseHistory, 1) end local grantProductSuccess = pcall(DevProducts[receiptInfo.ProductId], player, keep) if not grantProductSuccess then return Enum.ProductPurchaseDecision.NotProcessedYet end table.insert(keep.Data.PurchaseHistory, receiptInfo.PurchaseId) local saveSuccess = keep:Save():await() if not saveSuccess then return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end MarketplaceService.ProcessReceipt = processReceipt end return setProcessReceipt -- Main.luau local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local SetProcessReceipt = require(path_to_setprocessreceipt) local dataTemplate = { Coins = 0 } local keyPrefix = &quot;Player_&quot; local loadedKeeps = {} local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, dataTemplate):expect() local function onPlayerAdded(player: Player) keepStore:LoadKeep(keyPrefix .. player.UserId):andThen(function(keep) if keep == nil then player:Kick(&quot;Session lock interrupted!&quot;) end keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally state:andThen(function() print(`{player.Name}'s Keep has been released!`) player:Kick(&quot;Session released!&quot;) loadedKeeps[player] = nil end):catch(function(err) warn(`{player.Name}'s Keep failed to release!`, err) end) end) if not player:IsDescendantOf(Players) then keep:Release() return end loadedKeeps[player] = keep print(`Loaded {player.Name}'s Keep!`) end) end -- SetProcessReceipt() must be called before the onPlayerAdded(), -- otherwise the player's existing receipts won't be processed. SetProcessReceipt(keepStore, keyPrefix) -- loop through already connected players in case they joined before DataKeep loaded for _, player in Players:GetPlayers() do task.spawn(onPlayerAdded, player) end Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end) ","keywords":""},{"title":"Keep","type":0,"sectionRef":"#","url":"/DataKeep/api/Keep","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#types","content":" "},{"title":"Session​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Session","content":"&lt;/&gt; type Session = { PlaceId: number, JobId: string }   "},{"title":"MetaData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#MetaData","content":"&lt;/&gt; type MetaData = { ActiveSession: Session?, ForceLoad: Session?, LastUpdate: number, Created: number, LoadCount: number }   "},{"title":"GlobalUpdateData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdateData","content":"&lt;/&gt; type GlobalUpdateData = {[any]: any}   "},{"title":"GlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdate","content":"&lt;/&gt; type GlobalUpdate = { ID: number, Locked: boolean, Data: GlobalUpdateData }   "},{"title":"GlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdates","content":"&lt;/&gt; type GlobalUpdates = { ID: number, Updates: {GlobalUpdate} } ID is the most recent update index "},{"title":"Properties​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#properties","content":" "},{"title":"GlobalStateProcessor​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalStateProcessor","content":"&lt;/&gt; Keep.GlobalStateProcessor: ( updateData: GlobalUpdateData, lock: () → (), remove: () → () ) → () Define how to process global updates, by default just locks the global update (this is only ran if the Keep is online) The function reveals the lock and remove global update function through the parameters. caution Updates must be locked eventually in order for .OnGlobalUpdate to get fired. warning The lock and remove function revealed here are NOT the same as the ones in the Keep class, they are only for this function.  "},{"title":"OnGlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#OnGlobalUpdate","content":"&lt;/&gt; Keep.OnGlobalUpdate: Signal&lt;GlobalUpdateData,number&gt; Fired when a new global update is locked and ready to be processed, which can happen only during save caution ONLY locked globals are fired.  "},{"title":"Releasing​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Releasing","content":"&lt;/&gt; Keep.Releasing: Signal&lt;Promise&gt; Fired when the Keep is releasing (fires before internally released, but during session release) keep.Releasing:Connect(function(state) print(`Releasing {keep:Identify()}`) state:andThen(function() print(`Released {keep:Identify()}`) end, function() print(`Failed to release {keep:Identify()}`) end) end)   "},{"title":"Saving​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Saving","content":"&lt;/&gt; Keep.Saving: Signal&lt;Promise&gt; Fired when the Keep is saving, resolves on complete keep.Saving:Connect(function(state) print(`Saving {keep:Identify()}`) state:andThen(function() print(`Saved {keep:Identify()}`) end):catch(function() print(`Failed to save {keep:Identify()}`) end) end)   "},{"title":"Overwritten​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwritten","content":"&lt;/&gt; Keep.Overwritten: Signal&lt;boolean&gt; Fired when the Keep has been overwritten. Keep will be released if isReleasingSession is set to true keep.Overwritten:Connect(function(isReleasingSession) print(`{keep:Identify()} has been overwritten. Is releasing session: {isReleasingSession}`) end)  "},{"title":"Functions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#functions","content":" "},{"title":"Save​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Save","content":"&lt;/&gt; Keep:Save() → Promise Manually Saves a Keep. Commonly useful for speeding up global updates caution Calling :Save() manually will reset the auto save timer on the Keep. warning Using :Save() on a view-only Keep will error. Use :Overwrite() instead.  "},{"title":"Release​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Release","content":"&lt;/&gt; Keep:Release() → Promise Releases the session lock to allow other servers to access the Keep warning This is called before internal release, but after session release, no edits can be made after this point.  "},{"title":"Overwrite​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwrite","content":"&lt;/&gt; Keep:Overwrite(shouldKeepExistingSession: boolean?) → Promise Used to overwrite a view-only Keep. shouldKeepExistingSession controls the behavior of the server with the active session lock, defaults to false  "},{"title":"Destroy​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Destroy","content":"&lt;/&gt; Keep:Destroy() → () Destroys the Keep, removing all signals connections. Should be used only for cleaning view-only Keeps  "},{"title":"IsActive​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#IsActive","content":"&lt;/&gt; Keep:IsActive() → boolean Returns true if the Keep is active in the session (not locked by another server)  "},{"title":"Identify​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Identify","content":"&lt;/&gt; Keep:Identify() → string Returns the string identifier for the Keep  "},{"title":"GetKeyInfo​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetKeyInfo","content":"&lt;/&gt; Keep:GetKeyInfo() → DataStoreKeyInfo  Returns the DataStoreKeyInfo for the Keep  "},{"title":"Reconcile​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Reconcile","content":"&lt;/&gt; Keep:Reconcile() → () Fills in any missing data in the Keep, using the data template  "},{"title":"AddUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#AddUserId","content":"&lt;/&gt; Keep:AddUserId(userId: number) → () Associates a userId to a datastore to assist with GDPR requests (The right to erasure)  "},{"title":"RemoveUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#RemoveUserId","content":"&lt;/&gt; Keep:RemoveUserId(userId: number) → () Unassociates a userId from a datastore  "},{"title":"GetVersions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetVersions","content":"&lt;/&gt; Keep:GetVersions( minDate: number?, maxDate: number? ) → Promise&lt;Iterator&gt; "},{"title":"Types","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep##","content":""},{"title":"​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Iterator","content":"interface Iterator { Current: () → DataStoreObjectVersionInfo? -- Returns the current versionInfo, nil if none Next: () → DataStoreObjectVersionInfo? -- Returns the next versionInfo, nil if none Previous: () → DataStoreObjectVersionInfo? -- Returns the previous versionInfo, nil if none PageUp: () → ()-- Goes to the next page of versions PageDown: () → ()-- Goes to the previous page of versions SkipEnd: () → ()-- Goes to the last page of versions SkipStart: () → ()-- Goes to the first page of versions }  Grabs past versions of the Keep and returns an iterator to customize how to handle the versions &quot;I lost my progress! Last time I had 200 gems!&quot; keep:GetVersions():andThen(function(iterator) local versionInfo = iterator.Current() while versionInfo do local keep = keepStore:ViewKeep(player.UserId, versionInfo.Version):expect() if keep.Data.Gems &gt;= 200 then print(&quot;Found the version with 200 gems!&quot;) break end versionInfo = iterator.Next() end end)   "},{"title":"SetVersion​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#SetVersion","content":"&lt;/&gt; Keep:SetVersion( version: string, migrateProcessor: ((versionKeep: Keep) → Keep)? ) → Promise&lt;Keep&gt; "},{"title":"Types","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep##","content":""},{"title":"​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Keep","content":"type Keep = { Data: {[string]: any}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {number}, OnGlobalUpdate: Signal&lt;GlobalUpdateData, number&gt;, GlobalStateProcessor: ( update: GlobalUpdateData, lock: () → (), remove: () → () ) → (), Releasing: Signal&lt;Promise&gt;, Saving: Signal&lt;Promise&gt;, Overwritten: Signal&lt;boolean&gt; }  Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function DataKeep provides a version list iterator. See :GetVersions() Returns a Promise that resolves to the old Keep (before the migration) This is the last time the old Keep's GlobalUpdates will be accessible before permanently being removed warning Will not save until the next loop unless otherwise called using :Save() or :Overwrite() for view-only Keeps. caution Any global updates not taken care of in migrateProcessor will be lost.  "},{"title":"GetActiveGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetActiveGlobalUpdates","content":"&lt;/&gt; Keep:GetActiveGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of active global updates (not locked/processed)  "},{"title":"GetLockedGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetLockedGlobalUpdates","content":"&lt;/&gt; Keep:GetLockedGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of locked global updates (processed) caution Lock updates can not be changed, only cleared after done being used.  "},{"title":"ClearLockedUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#ClearLockedUpdate","content":"&lt;/&gt; Keep:ClearLockedUpdate(id: number) → Promise&lt;void&gt; Clears a locked global update after being used warning Passing an active global update id will throw an error &amp; reject the Promise. "},{"title":"DataKeep vs ProfileService","type":0,"sectionRef":"#","url":"/DataKeep/docs/Versus","content":"DataKeep vs ProfileService ProfileService by loleris is a great module. However, there are some minor opinionated flaws: Profile does not automatically clean up internal connections, making the developer have to perform inconvenient clean upsProfileService async calls make it difficult to wait for Profiles to be loaded. Causing weird patterns when waiting for Profiles, DataKeep is promise basedShorter, cleaner, scripts for faster future development, and contributors (vs ProfileService fitting classes inside one script for micro-performance)Type checking. There is one caveat due to Luau limitations, can not type check what Promises return (but shows on documentation)","keywords":""},{"title":"Store","type":0,"sectionRef":"#","url":"/DataKeep/api/Store","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#types","content":" "},{"title":"StoreInfo​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#StoreInfo","content":"&lt;/&gt; type StoreInfo = { Name: string, Scope: string? } Table format for a store's info in .GetStore()  "},{"title":"Store​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Store","content":"&lt;/&gt; type Store = { LoadMethods: LoadMethods, Mock: MockStore, LoadKeep: ( string, unreleasedHandler? ) → Promise&lt;Keep&gt;, ViewKeep: (string) → Promise&lt;Keep&gt;, PreSave: (({any}) → {any}) → (), PreLoad: (({any}) → {any}) → (), PostGlobalUpdate: ( string, (GlobalUpdates) → () ) → Promise&lt;void&gt;, IssueSignal: Signal, CriticalStateSignal: Signal, CriticalState: boolean } Stores are used to load and save Keeps from a DataStoreService:GetDataStore()  "},{"title":"LoadMethods​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadMethods","content":"&lt;/&gt; type LoadMethods = { ForceLoad: string, Steal: string, Cancel: string } &quot;ForceLoad&quot; (default) Attempts to load the Keep. If the Keep is session-locked, it will either be released for that remote server or &quot;stolen&quot; if it's not responding (possibly in dead lock). &quot;Steal&quot; Loads keep immediately, ignoring an existing remote session lock and applying a session lock for this session. &quot;Cancel&quot; Cancels the load of the Keep  "},{"title":"unreleasedHandler​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#unreleasedHandler","content":"&lt;/&gt; type unreleasedHandler = (Keep.ActiveSession) → string Used to determine how to handle an session locked Keep. info Check LoadMethods for more info. "},{"title":"Properties​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#properties","content":" "},{"title":"LoadMethods​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadMethods","content":"&lt;/&gt; Store.LoadMethods: LoadMethods   "},{"title":"Wrapper​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Wrapper","content":"&lt;/&gt; Store.Wrapper: {} Wrapper functions that are inheritted by Keeps when they are loaded info Any wrapper changes post .GetStore() will not apply to that store but the next one.  "},{"title":"Mock​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Mock","content":"&lt;/&gt; Store.Mock: MockStore A mock store that mirrors the real store, but doesn't save data  "},{"title":"IssueSignal​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#IssueSignal","content":"&lt;/&gt; Store.IssueSignal: Signal Fired when an issue occurs, like a failed request keepStore.IssueSignal:Connect(function(err) print(&quot;Issue!&quot;, err) end)   "},{"title":"CriticalStateSignal​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#CriticalStateSignal","content":"&lt;/&gt; Store.CriticalStateSignal: Signal Fired when the store enters critical state. After it has failed many requests and maybe dangerous to proceed with purchases or other important actions keepStore.CriticalStateSignal:Connect(function() print(&quot;Critical State!&quot;) end)   "},{"title":"CriticalState​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#CriticalState","content":"&lt;/&gt; Store.CriticalState: boolean Whether the store is in critical state or not. See CriticalStateSignal if keepStore.CriticalState then warn(&quot;Critical State!&quot;) return end -- process purchase   "},{"title":"validate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#validate","content":"&lt;/&gt; Store.validate: ({[string]: any}) → true | (false&amp;string) Used to validate data before saving. Ex. type guards keepStore.validate = function(data) for key, value in data do local dataTempVersion = dataTemplate[key] if typeof(data[key]) ~= typeof(dataTempVersion) then return false, `Invalid type for key: {key}` end end return true end  "},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#functions","content":" "},{"title":"GetStore​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#GetStore","content":"&lt;/&gt; Store.GetStore( storeInfo: StoreInfo | string, dataTemplate: any ) → Promise&lt;Store&gt; Loads a store from a DataStoreService:GetDataStore() and returns a Store object local keepStore = DataKeep.GetStore(&quot;TestStore&quot;, { Test = &quot;Hello World!&quot;, }):expect()   "},{"title":"LoadKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadKeep","content":"&lt;/&gt; Store:LoadKeep( key: string, unreleasedHandler: unreleasedHandler? ) → Promise&lt;Keep?&gt; Loads a Keep from the store and returns a Keep object keepStore:LoadKeep(`Player_{player.UserId}`, function() return keepStore.LoadMethods.ForceLoad end)):andThen(function(keep) if not keep then player:Kick(&quot;Session lock interrupted!&quot;) return end print(`Loaded {keep:Identify()}!`) end) info Stores can be loaded multiple times as they are cached, that way you can call :LoadKeep() and get the same cached Keeps.  "},{"title":"ViewKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#ViewKeep","content":"&lt;/&gt; Store:ViewKeep( key: string, version: string? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object, but doesn't save it View-only Keeps have the same functions as normal Keeps, but can not operate on data keepStore:ViewKeep(`Player_{player.UserId}`):andThen(function(viewOnlyKeep) print(`Viewing {viewOnlyKeep:Identify()}!`) end) warning View-only Keeps are not cached! warning Keep:Destroy() must be called when view-only Keep is not needed anymore.  "},{"title":"PreSave​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreSave","content":"&lt;/&gt; Store:PreSave(callback: ({[string]: any}) → {[string]: any}) → () Runs before saving a Keep, allowing you to modify the data before, like compressing data caution Callback must return a new data table. warning :PreSave() can only be set once. Compression example: keepStore:PreSave(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONEncode(value) end return newData end)   "},{"title":"PreLoad​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreLoad","content":"&lt;/&gt; Store:PreLoad(callback: ({[string]: any}) → {[string]: any}) → () Runs before loading a Keep, allowing you to modify the data before, like decompressing compressed data caution Callback must return a new data table. warning :PreLoad() can only be set once. Decompression example: keepStore:PreLoad(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONDecode(value) end return newData end)   "},{"title":"PostGlobalUpdate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PostGlobalUpdate","content":"&lt;/&gt; Store:PostGlobalUpdate( key: string, updateHandler: (GlobalUpdates) → () ) → Promise&lt;updatedData,DataStoreKeyInfo&gt; Posts a global update to a Keep updateHandler reveals globalUpdates to the API keepStore:PostGlobalUpdate(`Player_{player.UserId}`, function(globalUpdates) globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end) end)  "},{"title":"WriteLib","type":0,"sectionRef":"#","url":"/DataKeep/docs/WriteLib","content":"","keywords":""},{"title":"Defining a custom WriteLib​","type":1,"pageTitle":"WriteLib","url":"/DataKeep/docs/WriteLib#defining-a-custom-writelib","content":"-- WriteLib.luau return { AddCoins = function(self, amount: number) self.Data.Coins += amount end, RemoveCoins = function(self, amount: number) self.Data.Coins -= amount end, }  -- Main.luau local dataTemplate = { Coins = 0 } local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, dataTemplate):expect() keepStore.Wrapper = require(path_to_custom_WriteLib) keepStore:LoadKeep(`Player_{player.UserId}`):andThen(function(keep) keep:AddCoins(100) keep:RemoveCoins(50) end)  "},{"title":"Usage","type":0,"sectionRef":"#","url":"/DataKeep/docs/Usage","content":"","keywords":""},{"title":"Basic Approach​","type":1,"pageTitle":"Usage","url":"/DataKeep/docs/Usage#basic-approach","content":"DataKeep will lift everything, the only thing you need to do is load data. DataKeep does not use getter / setter functions allowing for customizable experience like, make your own wrapper. The following is a very basic Keep loader implementation. local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local dataTemplate = { Coins = 0, } local loadedKeeps = {} local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, dataTemplate) -- generally you can just :expect() I just want to showcase Promises to those unfamiliar local function onPlayerAdded(player: Player) keepStore:LoadKeep(`Player_{player.UserId}`):andThen(function(keep) if keep == nil then player:Kick(&quot;Session lock interrupted!&quot;) end keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally print(`{player.Name}'s Keep is releasing!`) state:andThen(function() print(`{player.Name}'s Keep has been released!`) player:Kick(&quot;Session released!&quot;) loadedKeeps[player] = nil end):catch(function(err) warn(`{player.Name}'s Keep failed to release!`, err) end) end) if not player:IsDescendantOf(Players) then keep:Release() return end loadedKeeps[player] = keep local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; local coins = Instance.new(&quot;NumberValue&quot;) coins.Name = &quot;Coins&quot; coins.Value = keep.Data.Coins leaderstats.Parent = player print(`Loaded {player.Name}'s Keep!`) end) end keepStore:andThen(function(store) keepStore = store -- loop through already connected players in case they joined before DataKeep loaded for _, player in Players:GetPlayers() do task.spawn(onPlayerAdded, player) end Players.PlayerAdded:Connect(onPlayerAdded) end) Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end)  "},{"title":"Class Approach​","type":1,"pageTitle":"Usage","url":"/DataKeep/docs/Usage#class-approach","content":"For more experienced developers I personally opt in to create a service that returns a &quot;Player&quot; OOP class that holds it own cleaner and a Keep inside. Note: &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent which contains numberValues / stringValues / boolValues --&gt; Services local Players = game:GetService(&quot;Players&quot;) --&gt; Includes local DataKeep = require(path_to_datakeep) local DataTemplate = require(script.Parent.DataTemplate) --&gt; Module Definition local Player = {} Player.__index = Player --&gt; Variables local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, DataTemplate):expect() --&gt; Private Functions local function initKeep(playerClass, keep) local player = playerClass.Player -- attributes &amp; leaderstats local attributes = Instance.new(&quot;Folder&quot;) attributes.Name = &quot;attributes&quot; attributes.Parent = player local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = player local function bindData(value, parent) -- leaderstats or attributes local doesExist = keep.Data[value.Name] if not doesExist then return end value = value:Clone() value.Value = keep.Data[value.Name] value:GetPropertyChangedSignal(&quot;Value&quot;):Connect(function() -- should clean on value destroy keep.Data[value.Name] = value.Value end) value.Parent = parent playerClass._keys[value.Name] = value end -- &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent -- which contains numberValues / stringValues / boolValues for _, attribute in script.Parent.attributes:GetChildren() do bindData(attribute, attributes) end for _, leaderstat in script.Parent.leaderstats:GetChildren() do bindData(leaderstat, leaderstats) end -- listen for globals end local function loadKeep(playerClass) local player = playerClass.Player local keep = keepStore:LoadKeep(`Player_{player.UserId}`) keep:andThen(function(dataKeep) if dataKeep == nil then player:Kick(&quot;Session lock interrupted!&quot;) end dataKeep:Reconcile() dataKeep:AddUserId(player.UserId) -- help with GDPR requests dataKeep.Releasing:Connect(function(releaseState) -- don't have to clean up, it cleans up internally releaseState :andThen(function() player:Kick(&quot;Session released!&quot;) playerClass:Destroy() end) :catch(function(err) warn(err) end) end) if not player:IsDescendantOf(Players) then playerClass:Destroy() return end initKeep(playerClass, dataKeep) end) return keep -- so they can attach to the promise end --&gt; Constructor function Player.new(player) local self = setmetatable({ Player = player, Keep = nil, _keys = {}, -- stored attribute / leaderstats keys for changing to automatically change the datakeep. **MUST USE THESE FOR ANY ATTRIBUTES / LEADERSTATS BINDED** }, Player) self.Keep = loadKeep(self) return self end --&gt; Public Methods function Player:GetKey(keyName: string) return self._keys[keyName] end function Player:GetData(key: string) local keep = self.Keep:expect() return keep.Data[key] end function Player:Destroy() -- do cleaning, this should generally include releasing the keep if self._destroyed then return end self._destroyed = true if self.Keep then local keep = self.Keep:expect() keep:Release() end end return Player  "}]