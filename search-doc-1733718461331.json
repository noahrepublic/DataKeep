{"searchDocs":[{"title":"GlobalUpdates","type":0,"sectionRef":"#","url":"/DataKeep/api/GlobalUpdates","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#types","content":" ","version":null,"tagName":"h2"},{"title":"GlobalUpdateData​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalUpdateData","content":"&lt;/&gt; type GlobalUpdateData = {[any]: any}   ","version":null,"tagName":"h3"},{"title":"GlobalUpdates​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalUpdates","content":"&lt;/&gt; type GlobalUpdates = { Id: number, Updates: {GlobalUpdate} } Id is the most recent update index. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#functions","content":" ","version":null,"tagName":"h2"},{"title":"AddGlobalUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#AddGlobalUpdate","content":"&lt;/&gt; GlobalUpdates:AddGlobalUpdate(globalUpdateData: {[any]: any}) → Promise&lt;number&gt; Adds a global update to the Keep. store:PostGlobalUpdate(function(globalUpdates) globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;, updateId) end) end)   ","version":null,"tagName":"h3"},{"title":"ChangeActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#ChangeActiveUpdate","content":"&lt;/&gt; GlobalUpdates:ChangeActiveUpdate( updateId: number, globalUpdateData: {[any]: any} ) → Promise&lt;()&gt; Change an active global update's data to the new data. Useful for stacking updates to save space for Keeps that maybe receiving lots of globals. Ex. a content creator receiving gifts.  ","version":null,"tagName":"h3"},{"title":"RemoveActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#RemoveActiveUpdate","content":"&lt;/&gt; GlobalUpdates:RemoveActiveUpdate(updateId: number) → Promise&lt;()&gt; Removes an active global update. local updates = globalUpdates:GetActiveUpdates() for _, update in updates do globalUpdates:RemoveActiveUpdate(update.Id):andThen(function() print(&quot;Removed Global Update!&quot;) end) end   ","version":null,"tagName":"h3"},{"title":"GetActiveUpdates​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GetActiveUpdates","content":"&lt;/&gt; GlobalUpdates:GetActiveUpdates() → {GlobalUpdate} ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalUpdate","content":"type GlobalUpdate = { Id: number, Locked: boolean, Data: GlobalUpdateData }  Returns all active global updates. local updates = globalUpdates:GetActiveUpdates() for _, update in updates do print(&quot;ActiveUpdate data:&quot;, update.Data) end  ","version":null,"tagName":"h3"},{"title":"DataKeep","type":0,"sectionRef":"#","url":"/DataKeep/api/DataKeep","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#types","content":" ","version":null,"tagName":"h2"},{"title":"LoadMethod​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#LoadMethod","content":"&lt;/&gt; type LoadMethod = { ForceLoad: string, Steal: string, Cancel: string } &quot;ForceLoad&quot; (default) Attempts to load the Keep. If the Keep is session-locked, it will either be released for that remote server or &quot;stolen&quot; if it's not responding (possibly in dead lock). &quot;Steal&quot; Loads keep immediately, ignoring an existing remote session lock and applying a session lock for this session. &quot;Cancel&quot; Cancels the load of the Keep.  ","version":null,"tagName":"h3"},{"title":"LogLevel​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#LogLevel","content":"&lt;/&gt; type LogLevel = { All: string, Warn: string, Error: string, None: string } &quot;All&quot; Logs everything. &quot;Warn&quot; (default) Logs warnings and errors. &quot;Error&quot; Logs errors only. &quot;None&quot; No logs.  ","version":null,"tagName":"h3"},{"title":"Wrapper​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#Wrapper","content":"&lt;/&gt; type Wrapper = {[string]: &lt;T&gt;( self: Keep, ...T ) → ()} Wrapper functions that are inheritted by Keeps when they are loaded. INFO Any wrapper changes after .GetStore() will not apply to that store but the next one.  ","version":null,"tagName":"h3"},{"title":"Enums​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#Enums","content":"&lt;/&gt; type Enums = { LoadMethod: LoadMethod, LogLevel: LogLevel }  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#properties","content":" ","version":null,"tagName":"h2"},{"title":"Enums​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#Enums","content":"&lt;/&gt; DataKeep.Enums: Enums   ","version":null,"tagName":"h3"},{"title":"Wrapper​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#Wrapper","content":"&lt;/&gt; DataKeep.Wrapper: Wrapper   ","version":null,"tagName":"h3"},{"title":"IssueSignal​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#IssueSignal","content":"&lt;/&gt; DataKeep.IssueSignal: Signal&lt;string&gt; Fired when an issue occurs, like a failed request. DataKeep.IssueSignal:Connect(function(err) print(&quot;Issue!&quot;, err) end)   ","version":null,"tagName":"h3"},{"title":"CriticalStateSignal​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#CriticalStateSignal","content":"&lt;/&gt; DataKeep.CriticalStateSignal: Signal&lt;boolean&gt; Fired when the store enters or exits critical state. After it has failed many requests and maybe dangerous to proceed with purchases or other important actions. DataKeep.CriticalStateSignal:Connect(function(isInCriticalState) if isInCriticalState then print(&quot;Critical state started!&quot;) else print(&quot;Critical state ended!&quot;) end end)  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#functions","content":" ","version":null,"tagName":"h2"},{"title":"GetStore​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#GetStore","content":"&lt;/&gt; DataKeep.GetStore( storeInfo: StoreInfo | string, dataTemplate: {[string]: any}, wrapper: Wrapper | {} ) → Promise&lt;Store&gt; Loads a store from a DataStoreService:GetDataStore() and returns a Store object. local dataTemplate = { Test = &quot;Hello World!&quot;, } local store = DataKeep.GetStore(&quot;TestStore&quot;, dataTemplate, {}):expect() INFO Stores can be loaded multiple times as they are cached.  ","version":null,"tagName":"h3"},{"title":"SetConfig​","type":1,"pageTitle":"DataKeep","url":"/DataKeep/api/DataKeep#SetConfig","content":"&lt;/&gt; DataKeep.SetConfig(overwrites: { assumeDeadLock: number?, internalKeepCleanupInterval: number?, loadKeepDataStoreFailTimeout: number?, saveInterval: number?, forceLoadMaxAttempts: number?, releaseRetryMaxAttempts: number?, criticalStateThreshold: number?, maxIssueTime: number?, maxCriticalStateTime: number?, logLevel: string? }) → () Allows to overwrite default config values. Only for experienced developers. DataKeep.SetConfig({ logLevel = DataKeep.Enums.LogLevel.All, saveInterval = 60, }) INFO Should be used before any other functions. ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/DataKeep/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Store","type":0,"sectionRef":"#","url":"/DataKeep/api/Store","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#types","content":" ","version":null,"tagName":"h2"},{"title":"StoreInfo​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#StoreInfo","content":"&lt;/&gt; type StoreInfo = { Name: string, Scope: string? } Table format for a store's info in .GetStore().  ","version":null,"tagName":"h3"},{"title":"unreleasedHandler​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#unreleasedHandler","content":"&lt;/&gt; type unreleasedHandler = (Session) → string Used to determine how to handle an session locked Keep. INFO Check LoadMethod for more info.  ","version":null,"tagName":"h3"},{"title":"StoreBase​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#StoreBase","content":"&lt;/&gt; type StoreBase = {}   ","version":null,"tagName":"h3"},{"title":"MockStore​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#MockStore","content":"&lt;/&gt; type MockStore = StoreBase MockStores are used to mirror the real store, but doesn't save data.  ","version":null,"tagName":"h3"},{"title":"Store​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Store","content":"&lt;/&gt; type Store = StoreBase &amp; {Mock: MockStore} Stores are used to load and save Keeps from a DataStoreService:GetDataStore(). ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#properties","content":" ","version":null,"tagName":"h2"},{"title":"Mock​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Mock","content":"&lt;/&gt; Store.Mock: MockStore Same as Store but it operates on a fake datastore. local store = DataKeep.GetStore(&quot;TestStore&quot;, {}, {}):expect() local keep = store.Mock:LoadKeep(&quot;TestKey&quot;):expect() keep:Release():await() -- must be used when done with the keep on live servers store.Mock:RemoveKeep(&quot;TestKey&quot;)   ","version":null,"tagName":"h3"},{"title":"validate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#validate","content":"&lt;/&gt; Store.validate: ({[string]: any}) → true | (false &amp; string) Used to validate data before saving. Ex. type guards. store.validate = function(data) for key, value in data do local dataTempVersion = dataTemplate[key] if typeof(data[key]) ~= typeof(dataTempVersion) then return false, `Invalid type for key: {key}` end end return true end  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#functions","content":" ","version":null,"tagName":"h2"},{"title":"Identify​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Identify","content":"&lt;/&gt; Store:Identify() → string Returns the string identifier for the Store.  ","version":null,"tagName":"h3"},{"title":"LoadKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadKeep","content":"&lt;/&gt; Store:LoadKeep( key: string, unreleasedHandler: unreleasedHandler? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object. store:LoadKeep(`Player_{player.UserId}`, function() return DataKeep.Enums.LoadMethod.ForceLoad end)):andThen(function(keep) print(`Loaded {keep:Identify()}!`) end):catch(function() player:Kick(&quot;Data failed to load&quot;) end) INFO Keeps are cached, that way you can call :LoadKeep() multiple times and get the same Keeps.  ","version":null,"tagName":"h3"},{"title":"ViewKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#ViewKeep","content":"&lt;/&gt; Store:ViewKeep( key: string, version: string? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object, but doesn't save it. View-only Keeps have the same functions as normal Keeps, but cannot operate on data. store:ViewKeep(`Player_{player.UserId}`):andThen(function(viewOnlyKeep) print(`Viewing {viewOnlyKeep:Identify()}!`) end):catch(function(err) warn(`Something went wrong! {err}`) end) DANGER View-only Keeps are not cached! DANGER Keep:Destroy() must be called when view-only Keep is not needed anymore.  ","version":null,"tagName":"h3"},{"title":"RemoveKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#RemoveKeep","content":"&lt;/&gt; Store:RemoveKeep(key: string) → Promise&lt;previousData,DataStoreKeyInfo &gt; Removes the key from the DataStore. INFO Calling :RemoveKeep() on the loaded Keep will release it (.Releasing signal will be fired) before removing. WARNING In live servers :RemoveKeep() must be used on Keeps created through mock stores.  ","version":null,"tagName":"h3"},{"title":"PreLoad​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreLoad","content":"&lt;/&gt; Store:PreLoad(callback: ({[string]: any}) → {[string]: any}) → () Runs before loading a Keep, allowing you to modify the data before, like decompressing compressed data. Decompression example: store:PreLoad(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONDecode(value) end return newData end) WARNING Callback must return a new data table. DANGER :PreLoad() can only be set once.  ","version":null,"tagName":"h3"},{"title":"PreSave​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreSave","content":"&lt;/&gt; Store:PreSave(callback: ({[string]: any}) → {[string]: any}) → () Runs before saving a Keep, allowing you to modify the data before, like compressing data. Compression example: store:PreSave(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONEncode(value) end return newData end) WARNING Callback must return a new data table. DANGER :PreSave() can only be set once.  ","version":null,"tagName":"h3"},{"title":"PostGlobalUpdate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PostGlobalUpdate","content":"&lt;/&gt; Store:PostGlobalUpdate( key: string, updateHandler: (GlobalUpdates) → () ) → Promise&lt;updatedData,DataStoreKeyInfo &gt; Posts a global update to a Keep. store:PostGlobalUpdate(`Player_{player.UserId}`, function(globalUpdates) globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end) end) INFO Check GlobalUpdates for more info. DANGER Yielding inside updateHandler is not allowed. ","version":null,"tagName":"h3"},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#manual","content":" Install through the rbxm file in the releases tab.  ","version":"Next","tagName":"h2"},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#wally","content":" Download the module through Wally by adding this package!  ","version":"Next","tagName":"h2"},{"title":"Git Submodule​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#git-submodule","content":" Add this Repository as a git submodule. ","version":"Next","tagName":"h2"},{"title":"Developer Products","type":0,"sectionRef":"#","url":"/DataKeep/docs/DevProducts","content":"Developer Products The following example shows how you would handle developer product purchases: DataTemplate.luau local dataTemplate = { PurchaseHistory = {}, Coins = 0, } export type template = typeof(dataTemplate) return table.freeze(dataTemplate) DevProducts.luau local DataKeep = require(path_to_datakeep) local DataTemplate = require(path_to_datatemplate) local devProducts = { [product_id_here] = function(player: Player, keep: DataKeep.Keep&lt;DataTemplate.template, {}&gt;) keep.Data.Coins += 100 print(`{player.Name} purchased some coins!`) end, } return devProducts SetProcessReceipt.luau local MarketplaceService = game:GetService(&quot;MarketplaceService&quot;) local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local DataTemplate = require(path_to_datatemplate) local DevProducts = require(path_to_devproducts) local purchaseHistoryLimit = 50 local function setProcessReceipt(store: DataKeep.Store&lt;DataTemplate.template, {}&gt;, keyPrefix: string) local function processReceipt(receiptInfo): Enum.ProductPurchaseDecision local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end local isLoaded, keep = store:LoadKeep(keyPrefix .. player.UserId):await() if not isLoaded then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep:IsActive() then return Enum.ProductPurchaseDecision.NotProcessedYet end if not keep.Data.PurchaseHistory then keep.Data.PurchaseHistory = {} end if table.find(keep.Data.PurchaseHistory, receiptInfo.PurchaseId) then -- the purchase has been added to the player's data, but it might not have saved yet local success = keep:Save():await() if success then return Enum.ProductPurchaseDecision.PurchaseGranted else return Enum.ProductPurchaseDecision.NotProcessedYet end end -- remove purchaseIds which are beyond the limit while #keep.Data.PurchaseHistory &gt;= purchaseHistoryLimit do table.remove(keep.Data.PurchaseHistory, 1) end local grantProductSuccess = pcall(DevProducts[receiptInfo.ProductId], player, keep) if not grantProductSuccess then return Enum.ProductPurchaseDecision.NotProcessedYet end table.insert(keep.Data.PurchaseHistory, receiptInfo.PurchaseId) local saveSuccess = keep:Save():await() if not saveSuccess then return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end MarketplaceService.ProcessReceipt = processReceipt end return setProcessReceipt Main.luau local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local DataTemplate = require(path_to_datatemplate) local SetProcessReceipt = require(path_to_setprocessreceipt) local keyPrefix = &quot;Player_&quot; local loadedKeeps = {} local store = DataKeep.GetStore(&quot;PlayerData&quot;, DataTemplate, {}):expect() local function onPlayerAdded(player: Player) store:LoadKeep(keyPrefix .. player.UserId):andThen(function(keep) keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally state:andThen(function() print(`{player.Name}'s Keep has been released!`) player:Kick(&quot;Session released!&quot;) loadedKeeps[player] = nil end):catch(function(err) warn(`{player.Name}'s Keep failed to release!`, err) end) end) if not player:IsDescendantOf(Players) then keep:Release() return end loadedKeeps[player] = keep print(`Loaded {player.Name}'s Keep!`) end):catch(function() player:Kick(&quot;Data failed to load&quot;) end) end -- SetProcessReceipt() must be called before the onPlayerAdded(), -- otherwise the player's existing receipts won't be processed. SetProcessReceipt(store, keyPrefix) -- loop through already connected players in case they joined before DataKeep loaded for _, player in Players:GetPlayers() do task.spawn(onPlayerAdded, player) end Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end) ","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/DataKeep/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#what-is-datakeep","content":" DataKeep is a module that loads and autosaves to datastores.  A Keep Datastore (Holds datastore saving information &amp; methods) automatically saves itself and cleans up for you.  ","version":"Next","tagName":"h2"},{"title":"Why DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#why-datakeep","content":" No getter/setter functions, allows ability to write your own wrapper interfaceSession Locking, prevents other servers from editing directly to prevent duplication exploits or overwriting data lossGlobalUpdates to communicate to offline KeepsSimilar API to previous data ModuleScript ProfileService allowing easy to pick upPromised base for control over exactly when things completeActively maintained, and accepting contributions  ","version":"Next","tagName":"h2"},{"title":"Ready to get started?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#ready-to-get-started","content":" InstallationAPI Documentation ","version":"Next","tagName":"h3"},{"title":"Keep","type":0,"sectionRef":"#","url":"/DataKeep/api/Keep","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#types","content":" ","version":null,"tagName":"h2"},{"title":"Session​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Session","content":"&lt;/&gt; type Session = { PlaceId: number, JobId: string }   ","version":null,"tagName":"h3"},{"title":"MetaData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#MetaData","content":"&lt;/&gt; type MetaData = { ActiveSession: Session?, ForceLoad: Session?, LastUpdate: number, Created: number, LoadCount: number }  ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#properties","content":" ","version":null,"tagName":"h2"},{"title":"GlobalStateProcessor​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalStateProcessor","content":"&lt;/&gt; Keep.GlobalStateProcessor: ( globalUpdateData: GlobalUpdateData, lock: () → (), remove: () → () ) → () Define how to process global updates, by default just locks the global update (this is only ran if the Keep is online). The function reveals the lock and remove global update function through the parameters. WARNING Updates must be locked eventually in order for .OnGlobalUpdate to get fired. DANGER The lock and remove function revealed here are NOT the same as the ones in the Keep class, they are only for this function.  ","version":null,"tagName":"h3"},{"title":"OnGlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#OnGlobalUpdate","content":"&lt;/&gt; Keep.OnGlobalUpdate: Signal&lt;GlobalUpdateData,number&gt; Fired when a new global update is locked and ready to be processed, which can happen only during save. WARNING ONLY locked globals are fired.  ","version":null,"tagName":"h3"},{"title":"Releasing​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Releasing","content":"&lt;/&gt; Keep.Releasing: Signal&lt;Promise&lt;()&gt;&gt; Fired when the Keep is releasing (fires before internally released, but during session release). keep.Releasing:Connect(function(state) print(`Releasing {keep:Identify()}`) state:andThen(function() print(`Released {keep:Identify()}`) end, function() print(`Failed to release {keep:Identify()}`) end) end)   ","version":null,"tagName":"h3"},{"title":"Saving​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Saving","content":"&lt;/&gt; Keep.Saving: Signal&lt;Promise&lt;()&gt;&gt; Fired when the Keep is saving, resolves on complete. keep.Saving:Connect(function(state) print(`Saving {keep:Identify()}`) state:andThen(function() print(`Saved {keep:Identify()}`) end):catch(function() print(`Failed to save {keep:Identify()}`) end) end)   ","version":null,"tagName":"h3"},{"title":"Overwritten​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwritten","content":"&lt;/&gt; Keep.Overwritten: Signal&lt;boolean&gt; Fired when the Keep has been overwritten. Keep will be released if isReleasingSession is set to true. keep.Overwritten:Connect(function(isReleasingSession) print(`{keep:Identify()} has been overwritten. Is releasing session: {isReleasingSession}`) end)  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#functions","content":" ","version":null,"tagName":"h2"},{"title":"Save​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Save","content":"&lt;/&gt; Keep:Save() → Promise&lt;()&gt; Performs a manual save. WARNING Calling :Save() manually will reset the auto save timer on the Keep. DANGER Using :Save() on a view-only Keep will error. Use :Overwrite() instead.  ","version":null,"tagName":"h3"},{"title":"Release​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Release","content":"&lt;/&gt; Keep:Release() → Promise&lt;()&gt; Releases the session lock to allow other servers to access the Keep. DANGER This is called before internal release, but after session release, no edits can be made after this point.  ","version":null,"tagName":"h3"},{"title":"Overwrite​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwrite","content":"&lt;/&gt; Keep:Overwrite(shouldKeepExistingSession: boolean?) → Promise&lt;()&gt; Used to overwrite a view-only Keep. shouldKeepExistingSession controls the behavior of the server with the active session lock, defaults to false.  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Destroy","content":"&lt;/&gt; Keep:Destroy() → () Destroys the Keep, removing all signals connections. Should be used only for cleaning view-only Keeps.  ","version":null,"tagName":"h3"},{"title":"IsActive​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#IsActive","content":"&lt;/&gt; Keep:IsActive() → boolean Returns true if the Keep is active in the session (not locked by another server).  ","version":null,"tagName":"h3"},{"title":"Identify​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Identify","content":"&lt;/&gt; Keep:Identify() → string Returns the string identifier for the Keep.  ","version":null,"tagName":"h3"},{"title":"GetKeyInfo​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetKeyInfo","content":"&lt;/&gt; Keep:GetKeyInfo() → DataStoreKeyInfo  Returns the DataStoreKeyInfo for the Keep.  ","version":null,"tagName":"h3"},{"title":"Reconcile​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Reconcile","content":"&lt;/&gt; Keep:Reconcile() → () Fills in any missing data in the Keep using the data template.  ","version":null,"tagName":"h3"},{"title":"AddUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#AddUserId","content":"&lt;/&gt; Keep:AddUserId(userId: number) → () Associates a userId to a datastore to assist with GDPR requests (The right to erasure).  ","version":null,"tagName":"h3"},{"title":"RemoveUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#RemoveUserId","content":"&lt;/&gt; Keep:RemoveUserId(userId: number) → () Unassociates a userId from a datastore.  ","version":null,"tagName":"h3"},{"title":"GetVersions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetVersions","content":"&lt;/&gt; Keep:GetVersions( minDate: number?, maxDate: number? ) → Promise&lt;Iterator&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Iterator","content":"interface Iterator { Current: () → DataStoreObjectVersionInfo? -- Returns the current versionInfo, nil if none. Next: () → DataStoreObjectVersionInfo? -- Returns the next versionInfo, nil if none. Previous: () → DataStoreObjectVersionInfo? -- Returns the previous versionInfo, nil if none. PageUp: () → ()-- Goes to the next page of versions. PageDown: () → ()-- Goes to the previous page of versions. SkipEnd: () → ()-- Goes to the last page of versions. SkipStart: () → ()-- Goes to the first page of versions. }  Grabs past versions of the Keep and returns an iterator to customize how to handle the versions. &quot;I lost my progress! Last time I had 200 gems!&quot; keep:GetVersions():andThen(function(iterator) local versionInfo = iterator.Current() while versionInfo do local oldKeep = store:ViewKeep(player.UserId, versionInfo.Version):expect() if oldKeep.Data.Gems &gt;= 200 then print(&quot;Found the version with 200 gems!&quot;) break end versionInfo = iterator.Next() end end)   ","version":null,"tagName":"h3"},{"title":"SetVersion​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#SetVersion","content":"&lt;/&gt; Keep:SetVersion( version: string, migrateProcessor: ((versionKeep: Keep) → Keep)? ) → Promise&lt;Keep&gt; ","version":null,"tagName":"h3"},{"title":"Types","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep##","content":"","version":null,"tagName":"h3"},{"title":"​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Keep","content":"type Keep = { Data: {[string]: any}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {number}, OnGlobalUpdate: Signal&lt;GlobalUpdateData, number&gt;, Releasing: Signal&lt;Promise&lt;()&gt;&gt;, Saving: Signal&lt;Promise&lt;()&gt;&gt;, Overwritten: Signal&lt;boolean&gt; }  Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function. DataKeep provides a version list iterator. See :GetVersions(). Returns a Promise that resolves to the old Keep (before the migration) This is the last time the old Keep's GlobalUpdates will be accessible before permanently being removed. DANGER Will not save until the next loop unless otherwise called using :Save() or :Overwrite() for view-only Keeps. WARNING Any global updates not taken care of in migrateProcessor will be lost.  ","version":null,"tagName":"h3"},{"title":"GetActiveGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetActiveGlobalUpdates","content":"&lt;/&gt; Keep:GetActiveGlobalUpdates() → {GlobalUpdate} Returns an array of active global updates (not locked / processed).  ","version":null,"tagName":"h3"},{"title":"GetLockedGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetLockedGlobalUpdates","content":"&lt;/&gt; Keep:GetLockedGlobalUpdates() → {GlobalUpdate} Returns an array of locked global updates (processed). WARNING Lock updates can not be changed, only cleared after done being used.  ","version":null,"tagName":"h3"},{"title":"ClearLockedUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#ClearLockedUpdate","content":"&lt;/&gt; Keep:ClearLockedUpdate(id: number) → Promise&lt;()&gt; Clears a locked global update after being used. DANGER Passing an active global update id will throw an error &amp; reject the Promise. ","version":null,"tagName":"h3"},{"title":"DataKeep vs ProfileService","type":0,"sectionRef":"#","url":"/DataKeep/docs/Versus","content":"DataKeep vs ProfileService ProfileService by loleris is a great module. However, there are some minor opinionated flaws: Profile does not automatically clean up internal connections, making the developer have to perform inconvenient clean upsProfileService async calls make it difficult to wait for Profiles to be loaded. Causing weird patterns when waiting for Profiles, DataKeep is promise basedShorter, cleaner scripts for faster future development and contributions (vs ProfileService one massive script for micro-performance)Type checking (Only first layer is fully typed in promises due to current luau limitations)","keywords":"","version":"Next"},{"title":"Usage","type":0,"sectionRef":"#","url":"/DataKeep/docs/Usage","content":"","keywords":"","version":"Next"},{"title":"Basic Approach​","type":1,"pageTitle":"Usage","url":"/DataKeep/docs/Usage#basic-approach","content":" DataKeep will lift everything, the only thing you need to do is load data. DataKeep does not use getter / setter functions allowing for customizable experience like, make your own wrapper.  The following is a very basic Keep loader implementation.  local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local dataTemplate = { Coins = 0, } local loadedKeeps = {} local store = DataKeep.GetStore(&quot;PlayerData&quot;, dataTemplate, {}):expect() local function onPlayerAdded(player: Player) store:LoadKeep(`Player_{player.UserId}`):andThen(function(keep) keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally print(`{player.Name}'s Keep is releasing!`) state:andThen(function() print(`{player.Name}'s Keep has been released!`) player:Kick(&quot;Session released!&quot;) loadedKeeps[player] = nil end):catch(function(err) warn(`{player.Name}'s Keep failed to release!`, err) end) end) if not player:IsDescendantOf(Players) then keep:Release() return end loadedKeeps[player] = keep local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; local coins = Instance.new(&quot;NumberValue&quot;) coins.Name = &quot;Coins&quot; coins.Value = keep.Data.Coins coins.Parent = leaderstats leaderstats.Parent = player print(`Loaded {player.Name}'s Keep!`) end):catch(function() player:Kick(&quot;Data failed to load&quot;) end) end -- loop through already connected players in case they joined before DataKeep loaded for _, player in Players:GetPlayers() do task.spawn(onPlayerAdded, player) end Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end)   ","version":"Next","tagName":"h2"},{"title":"WriteLib","type":0,"sectionRef":"#","url":"/DataKeep/docs/WriteLib","content":"","keywords":"","version":"Next"},{"title":"Defining a custom WriteLib​","type":1,"pageTitle":"WriteLib","url":"/DataKeep/docs/WriteLib#defining-a-custom-writelib","content":" WriteLib.luau return { AddCoins = function(self, amount: number) self.Data.Coins += amount end, RemoveCoins = function(self, amount: number) self.Data.Coins -= amount end, }   Main.luau local dataTemplate = { Coins = 0 } local wrapper = require(path_to_custom_WriteLib) local store = DataKeep.GetStore(&quot;PlayerData&quot;, dataTemplate, wrapper):expect() store:LoadKeep(`Player_{player.UserId}`):andThen(function(keep) keep:AddCoins(100) keep:RemoveCoins(50) end)  ","version":"Next","tagName":"h2"},{"title":"Class Approach​","type":1,"pageTitle":"Usage","url":"/DataKeep/docs/Usage#class-approach","content":" For more experienced developers I personally opt in to create a service that returns a &quot;Player&quot; OOP class that holds it own cleaner and a Keep inside.  Note: &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent which contains numberValues / stringValues / boolValues  --&gt; Services local Players = game:GetService(&quot;Players&quot;) --&gt; Includes local DataKeep = require(path_to_datakeep) local DataTemplate = require(path_to_datatemplate) --&gt; Module Definition local Player = {} Player.__index = Player --&gt; Variables local store = DataKeep.GetStore(&quot;PlayerData&quot;, DataTemplate, {}):expect() --&gt; Private Functions local function initKeep(playerClass, keep) local player = playerClass.Player -- attributes &amp; leaderstats local attributes = Instance.new(&quot;Folder&quot;) attributes.Name = &quot;attributes&quot; attributes.Parent = player local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = player local function bindData(value, parent) -- leaderstats or attributes local doesExist = keep.Data[value.Name] if not doesExist then return end value = value:Clone() value.Value = keep.Data[value.Name] value:GetPropertyChangedSignal(&quot;Value&quot;):Connect(function() -- should clean on value destroy keep.Data[value.Name] = value.Value end) value.Parent = parent playerClass._keys[value.Name] = value end -- &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent -- which contains numberValues / stringValues / boolValues for _, attribute in script.Parent.attributes:GetChildren() do bindData(attribute, attributes) end for _, leaderstat in script.Parent.leaderstats:GetChildren() do bindData(leaderstat, leaderstats) end -- listen for globals end local function loadKeep(playerClass) local player = playerClass.Player local keepPromise = store:LoadKeep(`Player_{player.UserId}`) keepPromise:andThen(function(keep) keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally state:andThen(function() player:Kick(&quot;Session released!&quot;) playerClass:Destroy() end):catch(function(err) warn(err) end) end) if not player:IsDescendantOf(Players) then playerClass:Destroy() return end initKeep(playerClass, keep) end):catch(function() player:Kick(&quot;Data failed to load&quot;) end) return keepPromise -- so they can attach to the promise end --&gt; Constructor function Player.new(player: Player) local self = setmetatable({ Player = player, Keep = nil, _keys = {}, -- stored attribute / leaderstats keys for changing to automatically change the datakeep. **MUST USE THESE FOR ANY ATTRIBUTES / LEADERSTATS BINDED** }, Player) self.Keep = loadKeep(self) return self end --&gt; Public Methods function Player:GetKey(keyName: string) return self._keys[keyName] end function Player:GetData(key: string) local keep = self.Keep:expect() return keep.Data[key] end function Player:Destroy() -- do cleaning, this should generally include releasing the keep if self._destroyed then return end self._destroyed = true if self.Keep then local keep = self.Keep:expect() keep:Release() end end return Player  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}