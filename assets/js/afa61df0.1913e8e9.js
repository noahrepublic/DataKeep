"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[385],{81971:e=>{e.exports=JSON.parse('{"functions":[{"name":"Save","desc":"Manually Saves a keep and returns the data from UpdateAsync()\\n\\nCommonly useful for speeding up global updates\\n\\n:::caution\\nRESETS AUTO SAVE TIMER ON THE KEEP\\n:::caution","params":[],"returns":[{"desc":"","lua_type":"KeepStruct"}],"function_type":"method","source":{"line":513,"path":"src/Keep.lua"}},{"name":"IsActive","desc":"Returns if the Keep is active in the session (not locked by another server)","params":[],"returns":[{"desc":"","lua_type":"{boolean}"}],"function_type":"method","source":{"line":543,"path":"src/Keep.lua"}},{"name":"Identify","desc":"Returns the string identifier for the Keep","params":[],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":556,"path":"src/Keep.lua"}},{"name":"GetKeyInfo","desc":"Returns the DataStoreKeyInfo for the Keep","params":[],"returns":[{"desc":"","lua_type":"DataStoreKeyInfo"}],"function_type":"method","source":{"line":574,"path":"src/Keep.lua"}},{"name":"Release","desc":"Releases the session lock to allow other servers to access the Keep \\n\\n:::warning\\nThis is called before internal release, but after session release, no edits can be made after this point\\n:::warning","params":[],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":591,"path":"src/Keep.lua"}},{"name":"Reconcile","desc":"Fills in any missing data in the Keep, using the data template","params":[],"returns":[{"desc":"","lua_type":"void"}],"function_type":"method","source":{"line":620,"path":"src/Keep.lua"}},{"name":"AddUserId","desc":"Associates a userId to a datastore to assist with GDPR requests (The right to erasure)","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":650,"path":"src/Keep.lua"}},{"name":"RemoveUserId","desc":"Unassociates a userId to a datastore","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":671,"path":"src/Keep.lua"}},{"name":"GetVersions","desc":"Grabs past versions of the Keep and returns an iterator to customize how to handle the versions\\n\\n\\"I lost my progress! Last time I had 200 gems!\\"\\n\\n```lua\\n\\tkeep:GetVersions():andThen(function(iterator)\\n\\t\\tlocal version = iterator.Current()\\n\\n\\t\\twhile version do\\n\\t\\t\\tlocal data = keepStore:ViewKeep(player.UserId, version.Version).Data\\n \\n\\t\\t\\tif data.Gems >= 200 then\\n\\t\\t\\t\\tprint(\\"Found the version with 200 gems!\\")\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tend\\n\\n\\t\\t\\tversion = iterator.Next()\\n\\t\\tend\\n\\tend)\\n```","params":[{"name":"minDate?","desc":"","lua_type":"number"},{"name":"maxDate?","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Promise<Iterator>"}],"function_type":"method","source":{"line":722,"path":"src/Keep.lua"}},{"name":"SetVersion","desc":"Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function\\n\\nDataKeep provides a version list iterator. See *GetVersions*\\n\\nReturns a Promise that resolves to the old keep (before the migration) This is the **last** time the old keep\'s GlobalUpdates will be accessible before **permanently** being removed\\n\\n:::warning\\nWill not save until the next loop unless otherwise called using :Save or :Overwrite for ViewOnly Keeps\\n:::warning\\n\\n:::caution\\nAny global updates not taken care of in migrateProcessor will be lost\\n:::caution","params":[{"name":"version","desc":"","lua_type":"string"},{"name":"migrateProcessor?","desc":"","lua_type":"(versionKeep: Keep) -> Keep"}],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":859,"path":"src/Keep.lua"}},{"name":"GetActiveGlobalUpdates","desc":"Returns an array of active global updates (not locked/processed)","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":907,"path":"src/Keep.lua"}},{"name":"GetLockedGlobalUpdates","desc":"Returns an array of locked global updates (processed)\\n\\n:::caution\\nLock updates can **not** be changed, only cleared after done being used.\\n:::caution","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":932,"path":"src/Keep.lua"}},{"name":"ClearLockedUpdate","desc":"Clears a locked global update after being used\\n\\n:::warning\\nPassing an **active** global update id will throw an error & reject the Promise. \\n:::warning","params":[{"name":"id","desc":"","lua_type":"{number}"}],"returns":[{"desc":"","lua_type":"Promise<void>"}],"function_type":"method","source":{"line":959,"path":"src/Keep.lua"}}],"properties":[{"name":"GlobalStateProcessor","desc":"Define how to process global updates, by default just locks the global update (this is only ran if the keep is online)\\n\\nThe function reveals the lock and remove global update function through the parameters.\\n\\n\\n\\n:::caution\\nUpdates *must* be locked eventually in order for OnGlobalUpdate to get fired\\n:::caution\\n\\n:::warning\\nThe lock and remove function revealed here are **NOT** the same as the ones in the Keep class, they are only for this function.\\n:::warning","lua_type":"(updateData: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void","source":{"line":144,"path":"src/Keep.lua"}},{"name":"OnGlobalUpdate","desc":"Fired when a new global update is locked and ready to be processed\\n\\n:::caution\\nONLY locked globals are fired\\n:::caution","lua_type":"Signal<(updateData: {}, updateId: number)>","source":{"line":155,"path":"src/Keep.lua"}},{"name":"OnRelease","desc":"Fired when the keep is released (fires before internally released, but after session release)","lua_type":"Signal<()>","source":{"line":162,"path":"src/Keep.lua"}}],"types":[{"name":"ActiveSession","desc":"","lua_type":"{PlaceID: number, JobID: number}","source":{"line":39,"path":"src/Keep.lua"}},{"name":"MetaData","desc":"","lua_type":"{ActiveSession: ActiveSession | nil, ForceLoad: ActiveSession | nil, LastUpdate: number, Created: number, LoadCount: number}","source":{"line":44,"path":"src/Keep.lua"}},{"name":"GlobalUpdates","desc":"","lua_type":"{ID: number, Updates: { [number]: GlobalUpdate }}","source":{"line":65,"path":"src/Keep.lua"}},{"name":"Keep","desc":"","lua_type":"{ Data: {}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {}, OnGlobalUpdate: Signal<GlobalUpdate & number>, GlobalStateProcessor: (update: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void, OnRelease: Signal}","source":{"line":213,"path":"src/Keep.lua"}},{"name":"Iterator","desc":"","lua_type":"{Current: () -> version?, Next: () -> version?, Previous: () -> version?, PageUp: () -> void, PageDown: () -> void, SkipEnd: () -> void, SkipStart: () -> void}","source":{"line":691,"path":"src/Keep.lua"}}],"name":"Keep","desc":"Keep class holds the data for a specific key in a store, and methods to manipulate data","realm":["Server"],"source":{"line":11,"path":"src/Keep.lua"}}')}}]);