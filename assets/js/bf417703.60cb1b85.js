"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[571],{4908:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"Usage","title":"Usage","description":"Basic Approach","source":"@site/docs/Usage.md","sourceDirName":".","slug":"/Usage","permalink":"/DataKeep/docs/Usage","draft":false,"unlisted":false,"editUrl":"https://github.com/noahrepublic/DataKeep/edit/main/docs/Usage.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Installation","permalink":"/DataKeep/docs/Installation"},"next":{"title":"WriteLib","permalink":"/DataKeep/docs/WriteLib"}}');var l=n(4848),r=n(8453);const s={sidebar_position:3},o="Usage",i={},d=[{value:"Basic Approach",id:"basic-approach",level:2},{value:"Class Approach",id:"class-approach",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.header,{children:(0,l.jsx)(t.h1,{id:"usage",children:"Usage"})}),"\n",(0,l.jsx)(t.h2,{id:"basic-approach",children:"Basic Approach"}),"\n",(0,l.jsx)(t.p,{children:"DataKeep will lift everything, the only thing you need to do is load data. DataKeep does not use getter / setter functions allowing for customizable experience like, make your own wrapper."}),"\n",(0,l.jsx)(t.p,{children:"The following is a very basic Keep loader implementation."}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-lua",children:'local Players = game:GetService("Players")\n\nlocal DataKeep = require(path_to_datakeep)\n\nlocal dataTemplate = {\n\tCoins = 0,\n}\n\nlocal loadedKeeps = {}\n\nlocal store = DataKeep.GetStore("PlayerData", dataTemplate):expect()\n\nlocal function onPlayerAdded(player: Player)\n\tstore:LoadKeep(`Player_{player.UserId}`):andThen(function(keep)\n\t\tkeep:Reconcile()\n\t\tkeep:AddUserId(player.UserId) -- help with GDPR requests\n\n\t\tkeep.Released:Connect(function()\n\t\t\tprint(`{player.Name}\'s Keep has been released!`)\n\n\t\t\tloadedKeeps[player] = nil\n\t\t\tplayer:Kick("Session released!")\n\t\tend)\n\n\t\tkeep.ReleaseFailed:Connect(function()\n\t\t\tprint(`Failed to release {player.Name}\'s Keep!`)\n\n\t\t\tloadedKeeps[player] = nil\n\t\t\tplayer:Kick("Failed to release session!")\n\t\tend)\n\n\t\tif not player:IsDescendantOf(Players) then\n\t\t\tkeep:Release():catch(function() end)\n\t\t\treturn\n\t\tend\n\n\t\tloadedKeeps[player] = keep\n\n\t\tlocal leaderstats = Instance.new("Folder")\n\t\tleaderstats.Name = "leaderstats"\n\n\t\tlocal coins = Instance.new("NumberValue")\n\t\tcoins.Name = "Coins"\n\t\tcoins.Value = keep.Data.Coins\n\t\tcoins.Parent = leaderstats\n\n\t\tleaderstats.Parent = player\n\n\t\tprint(`Loaded {player.Name}\'s Keep!`)\n\tend):catch(function()\n\t\tplayer:Kick("Data failed to load")\n\tend)\nend\n\n-- loop through already connected players in case they joined before DataKeep loaded\nfor _, player in Players:GetPlayers() do\n\ttask.spawn(onPlayerAdded, player)\nend\n\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n\nPlayers.PlayerRemoving:Connect(function(player)\n\tlocal keep = loadedKeeps[player]\n\n\tif not keep then\n\t\treturn\n\tend\n\n\tkeep:Release():catch(function() end)\nend)\n'})}),"\n",(0,l.jsx)(t.h2,{id:"class-approach",children:"Class Approach"}),"\n",(0,l.jsx)(t.p,{children:'For more experienced developers I personally opt in to create a service that returns a "Player" OOP class that holds it own cleaner and a Keep inside.'}),"\n",(0,l.jsx)(t.p,{children:'Note: "attributes" and "leaderstats" are folders in the script parent which contains numberValues / stringValues / boolValues'}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-lua",children:'--\x3e Services\n\nlocal Players = game:GetService("Players")\n\n--\x3e Includes\n\nlocal DataKeep = require(path_to_datakeep)\nlocal DataTemplate = require(path_to_datatemplate)\n\n--\x3e Module Definition\n\nlocal Player = {}\nPlayer.__index = Player\n\n--\x3e Variables\n\nlocal store = DataKeep.GetStore("PlayerData", DataTemplate):expect()\n\n--\x3e Private Functions\n\nlocal function initKeep(playerClass, keep)\n\tlocal player = playerClass.Player\n\n\t-- attributes & leaderstats\n\n\tlocal attributes = Instance.new("Folder")\n\tattributes.Name = "attributes"\n\tattributes.Parent = player\n\n\tlocal leaderstats = Instance.new("Folder")\n\tleaderstats.Name = "leaderstats"\n\tleaderstats.Parent = player\n\n\tlocal function bindData(value, parent) -- leaderstats or attributes\n\t\tlocal doesExist = keep.Data[value.Name]\n\n\t\tif not doesExist then\n\t\t\treturn\n\t\tend\n\n\t\tvalue = value:Clone()\n\n\t\tvalue.Value = keep.Data[value.Name]\n\n\t\tvalue:GetPropertyChangedSignal("Value"):Connect(function() -- should clean on value destroy\n\t\t\tkeep.Data[value.Name] = value.Value\n\t\tend)\n\n\t\tvalue.Parent = parent\n\n\t\tplayerClass._keys[value.Name] = value\n\tend\n\n    -- "attributes" and "leaderstats" are folders in the script parent\n\t-- which contains numberValues / stringValues / boolValues\n\n\tfor _, attribute in script.Parent.attributes:GetChildren() do\n\t\tbindData(attribute, attributes)\n\tend\n\n\tfor _, leaderstat in script.Parent.leaderstats:GetChildren() do\n\t\tbindData(leaderstat, leaderstats)\n\tend\n\n\t-- listen for globals\nend\n\nlocal function loadKeep(playerClass)\n\tlocal player = playerClass.Player\n\n\tlocal keepPromise = store:LoadKeep(`Player_{player.UserId}`)\n\n\tkeepPromise:andThen(function(keep)\n\t\tkeep:Reconcile()\n\t\tkeep:AddUserId(player.UserId) -- help with GDPR requests\n\n\t\tkeep.Released:Connect(function()\n\t\t\tprint(`{player.Name}\'s Keep has been released!`)\n\n\t\t\tplayerClass:Destroy()\n\t\t\tplayer:Kick("Session released!")\n\t\tend)\n\n\t\tkeep.ReleaseFailed:Connect(function()\n\t\t\tprint(`Failed to release {player.Name}\'s Keep!`)\n\n\t\t\tplayerClass:Destroy()\n\t\t\tplayer:Kick("Failed to release session!")\n\t\tend)\n\n\t\tif not player:IsDescendantOf(Players) then\n\t\t\tplayerClass:Destroy()\n\t\t\treturn\n\t\tend\n\n\t\tinitKeep(playerClass, keep)\n\tend):catch(function()\n\t\tplayer:Kick("Data failed to load")\n\tend)\n\n\treturn keepPromise -- so they can attach to the promise\nend\n\n--\x3e Constructor\n\nfunction Player.new(player: Player)\n\tlocal self = setmetatable({\n\t\tPlayer = player,\n\n\t\tKeep = nil,\n\n\t\t_keys = {}, -- stored attribute / leaderstats keys for changing to automatically change the datakeep. **MUST USE THESE FOR ANY ATTRIBUTES / LEADERSTATS BINDED**\n\t}, Player)\n\n\tself.Keep = loadKeep(self)\n\n\treturn self\nend\n\n--\x3e Public Methods\n\nfunction Player:GetKey(keyName: string)\n\treturn self._keys[keyName]\nend\n\nfunction Player:GetData(key: string)\n\tlocal keep = self.Keep:expect()\n\treturn keep.Data[key]\nend\n\nfunction Player:Destroy()\n\t-- do cleaning, this should generally include releasing the keep\n\n\tif self._destroyed then\n\t\treturn\n\tend\n\n\tself._destroyed = true\n\n\tif self.Keep then\n\t\tlocal keep = self.Keep:expect()\n\t\tkeep:Release():catch(function() end)\n\tend\nend\n\nreturn Player\n'})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const l={},r=a.createContext(l);function s(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);