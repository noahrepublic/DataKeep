"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[385],{81971:e=>{e.exports=JSON.parse('{"functions":[{"name":"Save","desc":"Manually Saves a Keep. Commonly useful for speeding up global updates\\n\\n:::caution\\nCalling ```:Save()``` manually will reset the auto save timer on the Keep.\\n:::caution\\n\\n:::warning\\nUsing ```:Save()``` on a **view-only Keep** will error. Use [:Overwrite()](#Overwrite) instead.\\n:::warning","params":[],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"method","source":{"line":535,"path":"src/Keep.luau"}},{"name":"Release","desc":"Releases the session lock to allow other servers to access the Keep\\n\\n:::warning\\nThis is called before internal release, but after session release, no edits can be made after this point.\\n:::warning","params":[],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"method","source":{"line":576,"path":"src/Keep.luau"}},{"name":"Overwrite","desc":"Used to overwrite a view-only Keep.\\n\\n```shouldKeepExistingSession``` controls the behavior of the server with the active session lock, defaults to ```false```","params":[{"name":"shouldKeepExistingSession","desc":"","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Promise"}],"function_type":"method","source":{"line":615,"path":"src/Keep.luau"}},{"name":"Destroy","desc":"Destroys the Keep, removing all signals connections. Should be used only for cleaning view-only Keeps","params":[],"returns":[],"function_type":"method","source":{"line":702,"path":"src/Keep.luau"}},{"name":"IsActive","desc":"Returns ```true``` if the Keep is active in the session (not locked by another server)","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","source":{"line":724,"path":"src/Keep.luau"}},{"name":"Identify","desc":"Returns the string identifier for the Keep","params":[],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":741,"path":"src/Keep.luau"}},{"name":"GetKeyInfo","desc":"Returns the ```DataStoreKeyInfo``` for the Keep","params":[],"returns":[{"desc":"","lua_type":"DataStoreKeyInfo"}],"function_type":"method","source":{"line":754,"path":"src/Keep.luau"}},{"name":"Reconcile","desc":"Fills in any missing data in the Keep, using the data template","params":[],"returns":[],"function_type":"method","source":{"line":765,"path":"src/Keep.luau"}},{"name":"AddUserId","desc":"Associates a ```userId``` to a datastore to assist with GDPR requests (The right to erasure)","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":795,"path":"src/Keep.luau"}},{"name":"RemoveUserId","desc":"Unassociates a ```userId``` from a datastore","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":812,"path":"src/Keep.luau"}},{"name":"GetVersions","desc":"Grabs past versions of the Keep and returns an iterator to customize how to handle the versions\\n\\n\\"I lost my progress! Last time I had 200 gems!\\"\\n\\n```lua\\nkeep:GetVersions():andThen(function(iterator)\\n\\tlocal versionInfo = iterator.Current()\\n\\n\\twhile versionInfo do\\n\\t\\tlocal keep = keepStore:ViewKeep(player.UserId, versionInfo.Version):expect()\\n\\n\\t\\tif keep.Data.Gems >= 200 then\\n\\t\\t\\tprint(\\"Found the version with 200 gems!\\")\\n\\t\\t\\tbreak\\n\\t\\tend\\n\\n\\t\\tversionInfo = iterator.Next()\\n\\tend\\nend)\\n```","params":[{"name":"minDate","desc":"","lua_type":"number?"},{"name":"maxDate","desc":"","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"Promise<Iterator>"}],"function_type":"method","source":{"line":874,"path":"src/Keep.luau"}},{"name":"SetVersion","desc":"Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional ```migrateProcessor``` function\\n\\nDataKeep provides a version list iterator. See [:GetVersions()](#GetVersions)\\n\\nReturns a Promise that resolves to the old Keep (before the migration) This is the **last** time the old Keep\'s GlobalUpdates will be accessible before **permanently** being removed\\n\\n:::warning\\nWill not save until the next loop unless otherwise called using [:Save()](#Save) or [:Overwrite()](#Overwrite) for view-only Keeps.\\n:::warning\\n\\n:::caution\\nAny global updates not taken care of in ```migrateProcessor``` will be lost.\\n:::caution","params":[{"name":"version","desc":"","lua_type":"string"},{"name":"migrateProcessor","desc":"","lua_type":"((versionKeep: Keep) -> Keep)?"}],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":1012,"path":"src/Keep.luau"}},{"name":"GetActiveGlobalUpdates","desc":"Returns an array of active global updates (not locked/processed)","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":1067,"path":"src/Keep.luau"}},{"name":"GetLockedGlobalUpdates","desc":"Returns an array of locked global updates (processed)\\n\\n:::caution\\nLock updates can **not** be changed, only cleared after done being used.\\n:::caution","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":1094,"path":"src/Keep.luau"}},{"name":"ClearLockedUpdate","desc":"Clears a locked global update after being used\\n\\n:::warning\\nPassing an **active** global update id will throw an error & reject the Promise.\\n:::warning","params":[{"name":"id","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Promise<void>"}],"function_type":"method","source":{"line":1123,"path":"src/Keep.luau"}}],"properties":[{"name":"GlobalStateProcessor","desc":"Define how to process global updates, by default just locks the global update (this is only ran if the Keep is online)\\n\\nThe function reveals the lock and remove global update function through the parameters.\\n\\n:::caution\\nUpdates **must** be locked eventually in order for [.OnGlobalUpdate](#OnGlobalUpdate) to get fired.\\n:::caution\\n\\n:::warning\\nThe lock and remove function revealed here are **NOT** the same as the ones in the Keep class, they are only for this function.\\n:::warning","lua_type":"(updateData: GlobalUpdateData, lock: () -> (), remove: () -> ()) -> ()","source":{"line":117,"path":"src/Keep.luau"}},{"name":"OnGlobalUpdate","desc":"Fired when a new global update is locked and ready to be processed, which can happen only during save\\n\\n:::caution\\n**ONLY** locked globals are fired.\\n:::caution","lua_type":"Signal<GlobalUpdateData, number>","source":{"line":128,"path":"src/Keep.luau"}},{"name":"Releasing","desc":"Fired when the Keep is releasing (fires before internally released, but during session release)\\n\\n```lua\\nkeep.Releasing:Connect(function(state)\\n\\tprint(`Releasing {keep:Identify()}`)\\n\\n\\tstate:andThen(function()\\n\\t\\tprint(`Released {keep:Identify()}`)\\n\\tend, function()\\n\\t\\tprint(`Failed to release {keep:Identify()}`)\\n\\tend)\\nend)\\n```","lua_type":"Signal<Promise>","source":{"line":147,"path":"src/Keep.luau"}},{"name":"Saving","desc":"Fired when the Keep is saving, resolves on complete\\n\\n```lua\\nkeep.Saving:Connect(function(state)\\n\\tprint(`Saving {keep:Identify()}`)\\n\\n\\tstate:andThen(function()\\n\\t\\tprint(`Saved {keep:Identify()}`)\\n\\tend):catch(function()\\n\\t\\tprint(`Failed to save {keep:Identify()}`)\\n\\tend)\\nend)\\n```","lua_type":"Signal<Promise>","source":{"line":166,"path":"src/Keep.luau"}},{"name":"Overwritten","desc":"Fired when the Keep has been overwritten. Keep will be released if ```isReleasingSession``` is set to ```true```\\n\\n```lua\\nkeep.Overwritten:Connect(function(isReleasingSession)\\n\\tprint(`{keep:Identify()} has been overwritten. Is releasing session: {isReleasingSession}`)\\nend)\\n```","lua_type":"Signal<boolean>","source":{"line":179,"path":"src/Keep.luau"}}],"types":[{"name":"Session","desc":"","lua_type":"{ PlaceId: number, JobId: string }","source":{"line":34,"path":"src/Keep.luau"}},{"name":"MetaData","desc":"","lua_type":"{ ActiveSession: Session?, ForceLoad: Session?, LastUpdate: number, Created: number, LoadCount: number }","source":{"line":44,"path":"src/Keep.luau"}},{"name":"GlobalUpdateData","desc":"","lua_type":"{ [any]: any }","source":{"line":49,"path":"src/Keep.luau"}},{"name":"GlobalUpdate","desc":"","lua_type":"{ ID: number, Locked: boolean, Data: GlobalUpdateData }","source":{"line":56,"path":"src/Keep.luau"}},{"name":"GlobalUpdates","desc":"```ID``` is the most recent update index","lua_type":"{ ID: number, Updates: { GlobalUpdate } }","source":{"line":69,"path":"src/Keep.luau"}},{"name":"Keep","desc":"","lua_type":"{ Data: { [string]: any }, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: { number }, OnGlobalUpdate: Signal<GlobalUpdateData, number>, GlobalStateProcessor: (update: GlobalUpdateData, lock: () -> (), remove: () -> ()) -> (), Releasing: Signal<Promise>, Saving: Signal<Promise>, Overwritten: Signal<boolean> }","source":{"line":228,"path":"src/Keep.luau"}},{"name":"Iterator","desc":"","fields":[{"name":"Current","lua_type":"() -> DataStoreObjectVersionInfo?","desc":"Returns the current versionInfo, nil if none"},{"name":"Next","lua_type":"() -> DataStoreObjectVersionInfo?","desc":"Returns the next versionInfo, nil if none"},{"name":"Previous","lua_type":"() -> DataStoreObjectVersionInfo?","desc":"Returns the previous versionInfo, nil if none"},{"name":"PageUp","lua_type":"() -> ()","desc":"Goes to the next page of versions"},{"name":"PageDown","lua_type":"() -> ()","desc":"Goes to the previous page of versions"},{"name":"SkipEnd","lua_type":"() -> ()","desc":"Goes to the last page of versions"},{"name":"SkipStart","lua_type":"() -> ()","desc":"Goes to the first page of versions"}],"source":{"line":843,"path":"src/Keep.luau"}}],"name":"Keep","desc":"Keep class holds the data for a specific key in a store, and methods to manipulate data","realm":["Server"],"source":{"line":18,"path":"src/Keep.luau"}}')}}]);