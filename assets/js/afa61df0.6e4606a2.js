"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[385],{81971:e=>{e.exports=JSON.parse('{"functions":[{"name":"Save","desc":"\\t\\n\\t\\nManually Saves a keep and returns the data from UpdateAsync()\\n\\t\\nCommonly useful for speeding up global updates\\n\\t\\n:::caution\\nRESETS AUTO SAVE TIMER ON THE KEEP\\n:::caution\\n\\t\\n:::warning\\nUsing :Save on a  **view only keep** will error. Use :Overwrite() instead\\n:::warning\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"Promise<DataStoreKeyInfo>"}],"function_type":"method","source":{"line":605,"path":"src/Keep.lua"}},{"name":"Overwrite","desc":"\\t\\nUsed to overwrite on a view only keep \\n\\t\\n:::warning\\nIgnores any session locks\\n:::warning\\n\\t\\n\\t","params":[],"returns":[{"desc":"","lua_type":"Promise<DataStoreKeyInfo>"}],"function_type":"method","source":{"line":647,"path":"src/Keep.lua"}},{"name":"IsActive","desc":"\\t\\n\\t\\nReturns if the Keep is active in the session (not locked by another server)\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"{boolean}"}],"function_type":"method","source":{"line":683,"path":"src/Keep.lua"}},{"name":"Identify","desc":"\\t\\n\\t\\nReturns the string identifier for the Keep\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"string"}],"function_type":"method","source":{"line":696,"path":"src/Keep.lua"}},{"name":"GetKeyInfo","desc":"\\t\\n\\t\\nReturns the DataStoreKeyInfo for the Keep\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"DataStoreKeyInfo"}],"function_type":"method","source":{"line":714,"path":"src/Keep.lua"}},{"name":"Release","desc":"\\t\\n\\t\\nReleases the session lock to allow other servers to access the Keep \\n\\t\\n:::warning\\nThis is called before internal release, but after session release, no edits can be made after this point\\n:::warning\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":731,"path":"src/Keep.lua"}},{"name":"Reconcile","desc":"\\t\\n\\t\\nFills in any missing data in the Keep, using the data template\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"void"}],"function_type":"method","source":{"line":801,"path":"src/Keep.lua"}},{"name":"AddUserId","desc":"\\t\\n\\t\\nAssociates a userId to a datastore to assist with GDPR requests (The right to erasure)\\n\\t\\t","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":831,"path":"src/Keep.lua"}},{"name":"RemoveUserId","desc":"\\t\\n\\t\\nUnassociates a userId to a datastore\\n\\t\\t","params":[{"name":"userId","desc":"","lua_type":"number"}],"returns":[],"function_type":"method","source":{"line":852,"path":"src/Keep.lua"}},{"name":"GetVersions","desc":"\\t\\n\\t\\n\\t\\nGrabs past versions of the Keep and returns an iterator to customize how to handle the versions\\n\\t\\n\\"I lost my progress! Last time I had 200 gems!\\"\\n\\t\\n```lua\\n\\tkeep:GetVersions():andThen(function(iterator)\\n\\t\\tlocal version = iterator.Current()\\n\\t\\n\\t\\twhile version do\\n\\t\\t\\tlocal data = keepStore:ViewKeep(player.UserId, version.Version).Data\\n\\t\\t\\n\\t\\t\\tif data.Gems >= 200 then\\n\\t\\t\\t\\tprint(\\"Found the version with 200 gems!\\")\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tend\\n\\t\\n\\t\\t\\tversion = iterator.Next()\\n\\t\\tend\\n\\tend)\\n```\\n\\t\\t","params":[{"name":"minDate?","desc":"","lua_type":"number"},{"name":"maxDate?","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Promise<Iterator>"}],"function_type":"method","source":{"line":912,"path":"src/Keep.lua"}},{"name":"SetVersion","desc":"\\t\\n\\t\\n\\t\\nAllows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function\\n\\t\\nDataKeep provides a version list iterator. See *GetVersions*\\n\\t\\nReturns a Promise that resolves to the old keep (before the migration) This is the **last** time the old keep\'s GlobalUpdates will be accessible before **permanently** being removed\\n\\t\\n:::warning\\nWill not save until the next loop unless otherwise called using :Save or :Overwrite for ViewOnly Keeps\\n:::warning\\n\\t\\n:::caution\\nAny global updates not taken care of in migrateProcessor will be lost\\n:::caution\\n\\t\\t","params":[{"name":"version","desc":"","lua_type":"string"},{"name":"migrateProcessor?","desc":"","lua_type":"(versionKeep: Keep) -> Keep"}],"returns":[{"desc":"","lua_type":"Promise<Keep>"}],"function_type":"method","source":{"line":1049,"path":"src/Keep.lua"}},{"name":"GetActiveGlobalUpdates","desc":"\\t\\n\\t\\nReturns an array of active global updates (not locked/processed)\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":1097,"path":"src/Keep.lua"}},{"name":"GetLockedGlobalUpdates","desc":"\\t\\n\\t\\nReturns an array of locked global updates (processed)\\n\\t\\n:::caution\\nLock updates can **not** be changed, only cleared after done being used.\\n:::caution\\n\\t\\t","params":[],"returns":[{"desc":"","lua_type":"{Array<{ Data: {}, ID: number }>}"}],"function_type":"method","source":{"line":1122,"path":"src/Keep.lua"}},{"name":"ClearLockedUpdate","desc":"\\t\\n\\t\\n\\t\\nClears a locked global update after being used\\n\\t\\n:::warning\\nPassing an **active** global update id will throw an error & reject the Promise. \\n:::warning\\n\\t\\t","params":[{"name":"id","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Promise<void>"}],"function_type":"method","source":{"line":1149,"path":"src/Keep.lua"}}],"properties":[{"name":"GlobalStateProcessor","desc":"\\t\\nDefine how to process global updates, by default just locks the global update (this is only ran if the keep is online)\\n\\t\\nThe function reveals the lock and remove global update function through the parameters.\\n\\t\\n\\t\\n\\t\\n:::caution\\nUpdates *must* be locked eventually in order for OnGlobalUpdate to get fired\\n:::caution\\n\\t\\n:::warning\\nThe lock and remove function revealed here are **NOT** the same as the ones in the Keep class, they are only for this function.\\n:::warning\\n\\t\\t","lua_type":"(updateData: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void","source":{"line":164,"path":"src/Keep.lua"}},{"name":"OnGlobalUpdate","desc":"\\t\\nFired when a new global update is locked and ready to be processed\\n\\t\\n:::caution\\nONLY locked globals are fired\\n:::caution\\n\\t\\t","lua_type":"Signal<(updateData: {}, updateId: number)>","source":{"line":175,"path":"src/Keep.lua"}},{"name":"Releasing","desc":"\\t\\nFired when the keep is releasing (fires before internally released, but during session release)\\n\\t\\n```lua\\nkeep.Releasing:Connect(function(state)\\n\\tprint(`Releasing {keep:Identify()}`)\\n\\tstate:andThen(function()\\n\\t\\tprint(`Released {keep:Identify()}`)\\n\\tend, function()\\n\\t\\tprint(`Failed to release {keep:Identify()}`)\\n\\tend)\\nend)\\n```\\n\\t","lua_type":"Signal<Promise>","source":{"line":193,"path":"src/Keep.lua"}},{"name":"Saving","desc":"\\t\\nFired when the keep is saving, resolves on complete\\n\\t\\n```lua\\nkeep.Saving:Connect(function(state)\\n\\tprint(`Saving {keep:Identify()}`)\\n\\t\\n\\tstate:andThen(function()\\n\\t\\tprint(`Saved {keep:Identify()}`)\\n\\tend):catch(function()\\n\\t\\tprint(`Failed to save {keep:Identify()}`)\\n\\tend)\\nend)\\n```\\n\\t","lua_type":"Signal<Promise>","source":{"line":212,"path":"src/Keep.lua"}}],"types":[{"name":"ActiveSession","desc":"\\t\\t","lua_type":"{PlaceID: number, JobID: number}","source":{"line":39,"path":"src/Keep.lua"}},{"name":"MetaData","desc":"\\t\\t","lua_type":"{ActiveSession: ActiveSession | nil, ForceLoad: ActiveSession | nil, LastUpdate: number, Created: number, LoadCount: number}","source":{"line":44,"path":"src/Keep.lua"}},{"name":"GlobalUpdates","desc":"\\t\\t","lua_type":"{ID: number, Updates: { [number]: GlobalUpdate }}","source":{"line":65,"path":"src/Keep.lua"}},{"name":"Keep","desc":"\\t\\t","lua_type":"{ Data: {}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {}, OnGlobalUpdate: Signal<GlobalUpdate & number>, GlobalStateProcessor: (update: GlobalUpdate, lock: () -> boolean, remove: () -> boolean) -> void, Releasing: Signal, Saving: Signal }","source":{"line":265,"path":"src/Keep.lua"}},{"name":"Iterator","desc":"\\t\\n\\t\\t","fields":[{"name":"Current","lua_type":"() -> version?","desc":"Returns the current version, nil if none"},{"name":"Next","lua_type":"() -> version?","desc":"Returns the next version, nil if none"},{"name":"Previous","lua_type":"() -> version?","desc":"Returns the previous version, nil if none"},{"name":"PageUp","lua_type":"() -> void","desc":"Goes to the next page of versions"},{"name":"PageDown","lua_type":"() -> void","desc":"Goes to the previous page of versions"},{"name":"SkipEnd","lua_type":"() -> void","desc":"Goes to the last page of versions"},{"name":"SkipStart","lua_type":"() -> void","desc":"Goes to the first page of versions"}],"source":{"line":881,"path":"src/Keep.lua"}}],"name":"Keep","desc":"Keep class holds the data for a specific key in a store, and methods to manipulate data\\n\\t","realm":["Server"],"source":{"line":11,"path":"src/Keep.lua"}}')}}]);