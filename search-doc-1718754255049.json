[{"title":"GlobalUpdates","type":0,"sectionRef":"#","url":"/DataKeep/api/GlobalUpdates","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#types","content":" "},{"title":"GlobalID​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalID","content":"&lt;/&gt; type GlobalID = number Used to identify a global update "},{"title":"Functions​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#functions","content":" "},{"title":"AddGlobalUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#AddGlobalUpdate","content":"&lt;/&gt; GlobalUpdates:AddGlobalUpdate(globalData: {}) → Promise&lt;GlobalID&gt; Adds a global update to the Keep globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end)   "},{"title":"GetActiveUpdates​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GetActiveUpdates","content":"&lt;/&gt; GlobalUpdates:GetActiveUpdates() → {GlobalUpdate} Returns all active global updates local updates = globalUpdates:GetActiveUpdates() for _, update in ipairs(updates) do print(update.Data) end   "},{"title":"RemoveActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#RemoveActiveUpdate","content":"&lt;/&gt; GlobalUpdates:RemoveActiveUpdate(updateId: GlobalID) → Promise&lt;void&gt; Removes an active global update local updates = globalUpdates:GetActiveUpdates() for _, update in ipairs(updates) do globalUpdates:RemoveActiveUpdate(update.ID):andThen(function() print(&quot;Removed Global Update!&quot;) end) end   "},{"title":"ChangeActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#ChangeActiveUpdate","content":"&lt;/&gt; GlobalUpdates:ChangeActiveUpdate( updateId: GlobalID, globalData: {} ) → Promise&lt;void&gt; Change an active global update's data to the new data. Useful for stacking updates to save space for Keeps that maybe receiving lots of globals. Ex. a content creator receiving gifts "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/DataKeep/docs/intro","content":"","keywords":""},{"title":"What is DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#what-is-datakeep","content":"DataKeep is a module that loads and autosaves to datastores A Keep Datastore (Holds datastore saving information &amp; methods) automatically saves itself and cleans up for you. "},{"title":"Why DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#why-datakeep","content":"No getter/setter functions, allows ability to write your own wrapper interfaceSession Locking, prevents other servers from editing directly to prevent duplication exploits or overwriting data lossGlobalUpdates to communicate to offline KeepsSimilar API to previous data ModuleScript ProfileService allowing easy to pick upPromised base for control over exactly when things completeActively maintained, and accepting contributions "},{"title":"Ready to get started?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#ready-to-get-started","content":"InstallationAPI Documentation "},{"title":"Installation","type":0,"sectionRef":"#","url":"/DataKeep/docs/Installation","content":"","keywords":""},{"title":"Manual installation​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#manual-installation","content":"Install through the rbxm file in the releases tab. "},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#wally","content":"Download the module through Wally by adding this package! "},{"title":"Git Submodule​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#git-submodule","content":"Add this Repository as a git submodule "},{"title":"Store","type":0,"sectionRef":"#","url":"/DataKeep/api/Store","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#types","content":" "},{"title":"StoreInfo​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#StoreInfo","content":"&lt;/&gt; type StoreInfo = { Name: string, Scope: string? } Table format for a store's info in .GetStore()  "},{"title":"Store​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Store","content":"&lt;/&gt; type Store = { LoadMethods: LoadMethods, Mock: MockStore, LoadKeep: ( string, unreleasedHandler? ) → Promise&lt;Keep&gt;, ViewKeep: (string) → Promise&lt;Keep&gt;, PreSave: (({any}) → {any}) → nil, PreLoad: (({any}) → {any}) → nil, PostGlobalUpdate: ( string, (GlobalUpdates) → nil ) → Promise&lt;void&gt;, IssueSignal: Signal, CriticalStateSignal: Signal, CriticalState: boolean } Stores are used to load and save Keeps from a DataStoreService:GetDataStore()  "},{"title":"LoadMethods​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadMethods","content":"&lt;/&gt; type LoadMethods = { ForceLoad: string, Cancel: string } &quot;ForceLoad&quot; (default) Steals the lock, releasing the previous session. It can take up to around 2 auto save cycles (1 on session that is requesting and 1 on session that already owns the lock) to release previous session and save new one if session is locked and up to around 10 minutes if session is in dead lock &quot;Cancel&quot; Cancels the load of the Keep  "},{"title":"unreleasedHandler​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#unreleasedHandler","content":"&lt;/&gt; type unreleasedHandler = (Keep.ActiveSession) → string Used to determine how to handle an session locked Keep. info Check LoadMethods for more info "},{"title":"Properties​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#properties","content":" "},{"title":"LoadMethods​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadMethods","content":"&lt;/&gt; Store.LoadMethods: LoadMethods   "},{"title":"Wrapper​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Wrapper","content":"&lt;/&gt; Store.Wrapper: {} Wrapper functions that are inheritted by Keeps when they are loaded info Any wrapper changes post .GetStore() will not apply to that store but the next one.  "},{"title":"Mock​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Mock","content":"&lt;/&gt; Store.Mock: MockStore A mock store that mirrors the real store, but doesn't save data  "},{"title":"IssueSignal​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#IssueSignal","content":"&lt;/&gt; Store.IssueSignal: Signal Fired when an issue occurs, like a failed request keepStore.IssueSignal:Connect(function(err) print(&quot;Issue!&quot;, err) end)   "},{"title":"CriticalStateSignal​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#CriticalStateSignal","content":"&lt;/&gt; Store.CriticalStateSignal: Signal Fired when the store enters critical state. After it has failed many requests and maybe dangerous to proceed with purchases or other important actions keepStore.CriticalStateSignal:Connect(function() print(&quot;Critical State!&quot;) end)   "},{"title":"CriticalState​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#CriticalState","content":"&lt;/&gt; Store.CriticalState: boolean Whether the store is in critical state or not. See CriticalStateSignal if keepStore.CriticalState then warn(&quot;Critical State!&quot;) return end -- process purchase   "},{"title":"validate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#validate","content":"&lt;/&gt; Store.validate: (any) → true | (false&amp;string) Used to validate data before saving. Ex. type guards keepStore.validate = function(data) for key, value in data do local dataTempVersion = dataTemplate[key] if typeof(data[key]) ~= typeof(dataTempVersion) then return false, &quot;Invalid type for key &quot; .. key end end return true end  "},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#functions","content":" "},{"title":"GetStore​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#GetStore","content":"&lt;/&gt; Store.GetStore( storeInfo: StoreInfo | string, dataTemplate: any ) → Promise&lt;Store&gt; Loads a store from a DataStoreService:GetDataStore() and returns a Store object local keepStore = DataKeep.GetStore(&quot;TestStore&quot;, { Test = &quot;Hello World!&quot;, }):expect()   "},{"title":"LoadKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadKeep","content":"&lt;/&gt; Store:LoadKeep( key: string, unreleasedHandler: unreleasedHandler? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object keepStore:LoadKeep(`Player_{player.UserId}`, function() return keepStore.LoadMethods.ForceLoad end)):andThen(function(keep) print(`Loaded {keep:Identify()}!`) end) info Stores can be loaded multiple times as they are cached, that way you can call :LoadKeep() and get the same cached Keeps  "},{"title":"ViewKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#ViewKeep","content":"&lt;/&gt; Store:ViewKeep( key: string, version: string? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object, but doesn't save it View only Keeps have the same functions as normal Keeps, but can not operate on data keepStore:ViewKeep(`Player_{player.UserId}`):andThen(function(viewOnlyKeep) print(`Viewing {viewOnlyKeep:Identify()}!`) end)   "},{"title":"PreSave​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreSave","content":"&lt;/&gt; Store:PreSave(callback: ({any}) → {any: any}) → () Runs before saving a Keep, allowing you to modify the data before, like compressing data caution Callback must return a new data table. warning :PreSave() can only be set once Compression example: keepStore:PreSave(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONEncode(value) end return newData end)   "},{"title":"PreLoad​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PreLoad","content":"&lt;/&gt; Store:PreLoad(callback: ({any}) → {any: any}) → () Runs before loading a Keep, allowing you to modify the data before, like decompressing compressed data caution Callback must return a new data table. warning :PreLoad() can only be set once Decompression example: keepStore:PreLoad(function(data) local newData = {} for key, value in data do newData[key] = HttpService:JSONDecode(value) end return newData end)   "},{"title":"PostGlobalUpdate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PostGlobalUpdate","content":"&lt;/&gt; Store:PostGlobalUpdate( key: string, updateHandler: (GlobalUpdates) → nil ) → Promise&lt;void&gt; Posts a global update to a Keep updateHandler reveals globalUpdates to the API keepStore:PostGlobalUpdate(`Player_{player.UserId}`, function(globalUpdates) globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end) end)  "},{"title":"DataKeep vs ProfileService","type":0,"sectionRef":"#","url":"/DataKeep/docs/Versus","content":"DataKeep vs ProfileService ProfileService by loleris is a great module. However, there are some minor opinionated flaws: Profile does not automatically clean up internal connections, making the developer have to perform inconvenient clean upsProfileService async calls make it difficult to wait for Profiles to be loaded. Causing weird patterns when waiting for Profiles, DataKeep is promise basedShorter, cleaner, scripts for faster future development, and contributors (vs ProfileService fitting classes inside one script for micro-performance)Type checking. There is one caveat due to Luau limitations, can not type check what Promises return (but shows on documentation)","keywords":""},{"title":"WriteLib","type":0,"sectionRef":"#","url":"/DataKeep/docs/WriteLib","content":"","keywords":""},{"title":"Defining a WriteLib​","type":1,"pageTitle":"WriteLib","url":"/DataKeep/docs/WriteLib#defining-a-writelib","content":"-- WriteLib.lua (stored anywheres you can access) return { AddCoins = function(keep, amount) keep.Data.Coins += amount end, RemoveCoins = function(keep, amount) keep.Data.Coins -= amount end, } -- main.lua local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, defaultData):expect() keepStore.Wrapper = require(path_to_WriteLib) keepStore:LoadKeep(`Player_{player.UserId}`):andThen(function(keep) keep:AddCoins(100) keep:RemoveCoins(50) end)  "},{"title":"Keep","type":0,"sectionRef":"#","url":"/DataKeep/api/Keep","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#types","content":" "},{"title":"Session​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Session","content":"&lt;/&gt; type Session = { PlaceID: number, JobID: string }   "},{"title":"MetaData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#MetaData","content":"&lt;/&gt; type MetaData = { ActiveSession: Session?, ForceLoad: Session?, LastUpdate: number, Created: number, LoadCount: number }   "},{"title":"GlobalUpdateData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdateData","content":"&lt;/&gt; type GlobalUpdateData = {[any]: any}   "},{"title":"GlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdate","content":"&lt;/&gt; type GlobalUpdate = { ID: number, Locked: boolean, Data: GlobalUpdateData }   "},{"title":"GlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdates","content":"&lt;/&gt; type GlobalUpdates = { ID: number, Updates: {GlobalUpdate} } ID is the most recent update index  "},{"title":"Keep​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Keep","content":"&lt;/&gt; type Keep = { Data: {}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {number}, OnGlobalUpdate: Signal&lt;GlobalUpdateData, number&gt;, GlobalStateProcessor: ( update: GlobalUpdateData, lock: () → boolean, remove: () → boolean ) → (), Releasing: Signal&lt;Promise&gt;, Saving: Signal&lt;Promise&gt;, Overwritten: Signal&lt;boolean&gt; }  "},{"title":"Properties​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#properties","content":" "},{"title":"GlobalStateProcessor​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalStateProcessor","content":"&lt;/&gt; Keep.GlobalStateProcessor: ( updateData: GlobalUpdateData, lock: () → boolean, remove: () → boolean ) → () Define how to process global updates, by default just locks the global update (this is only ran if the keep is online) The function reveals the lock and remove global update function through the parameters. caution Updates must be locked eventually in order for .OnGlobalUpdate to get fired warning The lock and remove function revealed here are NOT the same as the ones in the Keep class, they are only for this function.  "},{"title":"OnGlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#OnGlobalUpdate","content":"&lt;/&gt; Keep.OnGlobalUpdate: Signal&lt;GlobalUpdateData,number&gt; Fired when a new global update is locked and ready to be processed caution ONLY locked globals are fired  "},{"title":"Releasing​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Releasing","content":"&lt;/&gt; Keep.Releasing: Signal&lt;Promise&gt; Fired when the keep is releasing (fires before internally released, but during session release) keep.Releasing:Connect(function(state) print(`Releasing {keep:Identify()}`) state:andThen(function() print(`Released {keep:Identify()}`) end, function() print(`Failed to release {keep:Identify()}`) end) end)   "},{"title":"Saving​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Saving","content":"&lt;/&gt; Keep.Saving: Signal&lt;Promise&gt; Fired when the keep is saving, resolves on complete keep.Saving:Connect(function(state) print(`Saving {keep:Identify()}`) state:andThen(function() print(`Saved {keep:Identify()}`) end):catch(function() print(`Failed to save {keep:Identify()}`) end) end)   "},{"title":"Overwritten​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwritten","content":"&lt;/&gt; Keep.Overwritten: Signal&lt;boolean&gt; Fired when the keep has been overwritten. Keep will be released if isReleasingSession is true keep.Overwritten:Connect(function(isReleasingSession) print(`{keep:Identify()} has been overwritten. Is releasing session: {isReleasingSession}`) end)  "},{"title":"Functions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#functions","content":" "},{"title":"Save​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Save","content":"&lt;/&gt; Keep:Save() → Promise&lt;Keep&gt; Manually Saves a Keep. Commonly useful for speeding up global updates caution Calling :Save() manually will reset the auto save timer on the Keep warning Using :Save() on a view only keep will error. Use :Overwrite() instead  "},{"title":"Overwrite​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Overwrite","content":"&lt;/&gt; Keep:Overwrite(releaseExistingSession: boolean?) → Promise&lt;Keep&gt; Used to overwrite on a view only keep. releaseExistingSession controls the behavior of the server with the active session lock, defaults to true  "},{"title":"IsActive​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#IsActive","content":"&lt;/&gt; Keep:IsActive() → boolean Returns true if the Keep is active in the session (not locked by another server)  "},{"title":"Identify​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Identify","content":"&lt;/&gt; Keep:Identify() → string Returns the string identifier for the Keep  "},{"title":"GetKeyInfo​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetKeyInfo","content":"&lt;/&gt; Keep:GetKeyInfo() → DataStoreKeyInfo  Returns the DataStoreKeyInfo for the Keep  "},{"title":"Release​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Release","content":"&lt;/&gt; Keep:Release() → Promise&lt;Keep&gt; Releases the session lock to allow other servers to access the Keep warning This is called before internal release, but after session release, no edits can be made after this point  "},{"title":"Reconcile​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Reconcile","content":"&lt;/&gt; Keep:Reconcile() → () Fills in any missing data in the Keep, using the data template  "},{"title":"AddUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#AddUserId","content":"&lt;/&gt; Keep:AddUserId(userId: number) → () Associates a userId to a datastore to assist with GDPR requests (The right to erasure)  "},{"title":"RemoveUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#RemoveUserId","content":"&lt;/&gt; Keep:RemoveUserId(userId: number) → () Unassociates a userId from a datastore  "},{"title":"GetVersions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetVersions","content":"&lt;/&gt; Keep:GetVersions( minDate: number?, maxDate: number? ) → Promise&lt;Iterator&gt; "},{"title":"Types","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep##","content":""},{"title":"​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Iterator","content":"interface Iterator { Current: () → version?-- Returns the current version, nil if none Next: () → version?-- Returns the next version, nil if none Previous: () → version?-- Returns the previous version, nil if none PageUp: () → ()-- Goes to the next page of versions PageDown: () → ()-- Goes to the previous page of versions SkipEnd: () → ()-- Goes to the last page of versions SkipStart: () → ()-- Goes to the first page of versions }  Grabs past versions of the Keep and returns an iterator to customize how to handle the versions &quot;I lost my progress! Last time I had 200 gems!&quot; keep:GetVersions():andThen(function(iterator) local version = iterator.Current() while version do local data = keepStore:ViewKeep(player.UserId, version.Version).Data if data.Gems &gt;= 200 then print(&quot;Found the version with 200 gems!&quot;) break end version = iterator.Next() end end)   "},{"title":"SetVersion​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#SetVersion","content":"&lt;/&gt; Keep:SetVersion( version: string, migrateProcessor: ((versionKeep: Keep) → Keep)? ) → Promise&lt;Keep&gt; Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function DataKeep provides a version list iterator. See GetVersions Returns a Promise that resolves to the old keep (before the migration) This is the last time the old keep's GlobalUpdates will be accessible before permanently being removed warning Will not save until the next loop unless otherwise called using :Save() or :Overwrite() for view only Keeps caution Any global updates not taken care of in migrateProcessor will be lost  "},{"title":"GetActiveGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetActiveGlobalUpdates","content":"&lt;/&gt; Keep:GetActiveGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of active global updates (not locked/processed)  "},{"title":"GetLockedGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetLockedGlobalUpdates","content":"&lt;/&gt; Keep:GetLockedGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of locked global updates (processed) caution Lock updates can not be changed, only cleared after done being used.  "},{"title":"ClearLockedUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#ClearLockedUpdate","content":"&lt;/&gt; Keep:ClearLockedUpdate(id: number) → Promise&lt;void&gt; Clears a locked global update after being used warning Passing an active global update id will throw an error &amp; reject the Promise. "},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/DataKeep/docs/Usage","content":"Basic Usage DataKeep will lift everything, the only thing you need to do is load data. DataKeep does not use getter/setter functions allowing for customizable experience like, make your own wrapper. The following is a very basic Keep loader implementation. local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local defaultData = { Coins = 0, } local loadedKeeps = {} local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, defaultData) -- generally you can just :expect() I just want to showcase Promises to those unfamiliar local function onPlayerJoin(player) keepStore:LoadKeep(&quot;Player_&quot; .. player.UserId):andThen(function(keep) if keep == nil then player:Kick(&quot;Data locked&quot;) -- will never happen, when no releaseHandler is passed it default steals from the locked session end keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.Releasing:Connect(function(state) -- don't have to clean up, it cleans up internally. print(`{player.Name}'s Keep is releasing!`) state:andThen(function() print(`{player.Name}'s Keep has been released!`) player:Kick(&quot;Session Release&quot;) end):catch(function(err) warn(`{player.Name}'s Keep failed to release!`, err) end) end) if not player:IsDescendantOf(Players) then keep:Release() return end print(`Loaded {player.Name}'s Keep!`) loadedKeeps[player] = keep local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; local coins = Instance.new(&quot;NumberValue&quot;) coins.Name = &quot;Coins&quot; coins.Value = keep.Data.Coins leaderstats.Parent = player end) end Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end) keepStore:andThen(function(store) keepStore = store for _, player in Players:GetPlayers() do task.spawn(onPlayerJoin, player) end Players.PlayerAdded:Connect(onPlayerJoin) end) Class Approach For more experienced developers I personally opt in to create a service that returns a &quot;Player&quot; OOP class that holds it own cleaner and a Keep inside. Note: &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent which contains numbervalues/stringvalues/boolvalues --&gt; Services local Players = game:GetService(&quot;Players&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) --&gt; Includes local ServerPackages = ServerStorage.Packages local DataKeep = require(ServerPackages.DataKeep) local DataTemplate = require(script.Parent.DataTemplate) --&gt; Module Definition local Player = {} Player.__index = Player --&gt; Variables local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, DataTemplate):expect() --&gt; Private Functions local function initKeep(playerClass, keep) local player = playerClass.Player -- attributes &amp; leaderstats local attributes = Instance.new(&quot;Folder&quot;) attributes.Name = &quot;attributes&quot; attributes.Parent = player local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; leaderstats.Parent = player local function bindData(value, parent) -- leaderstats or attributes local doesExist = keep.Data[value.Name] if not doesExist then return end value = value:Clone() value.Value = keep.Data[value.Name] value:GetPropertyChangedSignal(&quot;Value&quot;):Connect(function() -- should clean on value destroy keep.Data[value.Name] = value.Value end) value.Parent = parent playerClass._keys[value.Name] = value end -- &quot;attributes&quot; and &quot;leaderstats&quot; are folders in the script parent which contains numbervalues/stringvalues/boolvalues for _, attribute in ipairs(script.Parent.attributes:GetChildren()) do bindData(attribute, attributes) end for _, leaderstat in ipairs(script.Parent.leaderstats:GetChildren()) do bindData(leaderstat, leaderstats) end -- listen for globals end local function loadKeep(playerClass) local player = playerClass.Player local keep = keepStore:LoadKeep(&quot;Player_&quot; .. player.UserId) keep:andThen(function(dataKeep) if dataKeep == nil then player:Kick(&quot;Data locked&quot;) end -- add userids dataKeep:Reconcile() dataKeep.Releasing:Connect(function(releaseState) -- no clean needed-- datakeep releases internals releaseState :andThen(function() player:Kick(&quot;Session released&quot;) end) :catch(function(err) warn(err) end) end) if not player:IsDescendantOf(Players) then playerClass:Destroy() return end initKeep(playerClass, dataKeep) end) return keep -- so they can attach to the promise end --&gt; Constructor function Player.new(player) local self = setmetatable({ Player = player, Maid = Maid.new(), Keep = {}, _keys = {}, -- stored attribute/leaderstats keys for changing to automatically change the datakeep. **MUST USE THESE FOR ANY ATTRIBUTES/LEADERSTATS BINDED** }, Player) self.Keep = loadKeep(self) return self end function Player:GetKey(keyName: string) return self._keys[keyName] end function Player:GetData(key: string) local keep = self.Keep:expect() return keep.Data[key] end function Player:Destroy() -- do cleaning, this should generally include releasing the keep end --&gt; Public Methods return Player ","keywords":""}]