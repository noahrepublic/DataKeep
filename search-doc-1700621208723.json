[{"title":"Installation","type":0,"sectionRef":"#","url":"/DataKeep/docs/Installation","content":"","keywords":""},{"title":"Manual installation​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#manual-installation","content":"Install through the rbxm file in the releases tab. "},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#wally","content":"Download the module through Wally by adding this package! "},{"title":"Git Submodule​","type":1,"pageTitle":"Installation","url":"/DataKeep/docs/Installation#git-submodule","content":"Add this Repository as a git submodule "},{"title":"GlobalUpdates","type":0,"sectionRef":"#","url":"/DataKeep/api/GlobalUpdates","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#types","content":" "},{"title":"GlobalID​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GlobalID","content":"&lt;/&gt; type GlobalID = number Used to identify a global update "},{"title":"Functions​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#functions","content":" "},{"title":"AddGlobalUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#AddGlobalUpdate","content":"&lt;/&gt; GlobalUpdates:AddGlobalUpdate(globalData: {}) → Promise&lt;GlobalID&gt; Adds a global update to the Keep globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end)   "},{"title":"GetActiveUpdates​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#GetActiveUpdates","content":"&lt;/&gt; GlobalUpdates:GetActiveUpdates() → {GlobalUpdate} Returns all active global updates local updates = globalUpdates:GetActiveUpdates() for _, update in ipairs(updates) do print(update.Data) end   "},{"title":"RemoveActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#RemoveActiveUpdate","content":"&lt;/&gt; GlobalUpdates:RemoveActiveUpdate(updateId: GlobalID) → Promise&lt;void&gt; Removes an active global update local updates = globalUpdates:GetActiveUpdates() for _, update in ipairs(updates) do globalUpdates:RemoveActiveUpdate(update.ID):andThen(function() print(&quot;Removed Global Update!&quot;) end) end   "},{"title":"ChangeActiveUpdate​","type":1,"pageTitle":"GlobalUpdates","url":"/DataKeep/api/GlobalUpdates#ChangeActiveUpdate","content":"&lt;/&gt; GlobalUpdates:ChangeActiveUpdate( updateId: GlobalID, globalData: {} ) → Promise&lt;void&gt; Change an active global update's data to the new data. Useful for stacking updates to save space for Keeps that maybe recieving lots of globals. Ex. A YouTuber recieving gifts "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/DataKeep/docs/intro","content":"","keywords":""},{"title":"What is DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#what-is-datakeep","content":"DataKeep is a module that loads and autosaves to datastores A Keep Datastore (Holds datastore saving information &amp; methods) automatically saves itself and cleans up for you. "},{"title":"Why DataKeep?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#why-datakeep","content":"No getter/setter functions, allows ability to write your own wrapper interfaceSession Locking, prevents other servers from editing directly to prevent duplication exploits or overwriting data lossGlobalUpdates to communicate to offline KeepsSimilar API to previous data ModuleScript ProfileService allowing easy to pick upPromised base for control over exactly when things completeActively maintained, and accepting contributions "},{"title":"Ready to get started?​","type":1,"pageTitle":"Getting Started","url":"/DataKeep/docs/intro#ready-to-get-started","content":"InstallationAPI Documentation "},{"title":"DataKeep vs ProfileService","type":0,"sectionRef":"#","url":"/DataKeep/docs/Versus","content":"DataKeep vs ProfileService ProfileService by loleris is a great module. However, there are some minor opinionated flaws: Profile does not automatically clean up internal connections, making the developer have to perform inconvenient clean upsProfileService async calls make it difficult to wait for Profiles to be loaded. Causing weird patterns when waiting for Profiles, DataKeep is promise basedShorter, cleaner, scripts for faster future development, and contributors (vs ProfileService fitting classes inside one script for micro-performance)Type checking. There is one caveat due to Luau limitations, can not type check what Promises return (but shows on documentation)","keywords":""},{"title":"Store","type":0,"sectionRef":"#","url":"/DataKeep/api/Store","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#types","content":" "},{"title":"StoreInfo​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#StoreInfo","content":"&lt;/&gt; type StoreInfo = { Name: string, Scope: string? } Table format for a store's info in :GetStore()  "},{"title":"Store​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Store","content":"&lt;/&gt; type Store = { Mock: MockStore, LoadKeep: ( string, UnReleasedHandler? ) → Promise&lt;Keep&gt;, ViewKeep: (string) → Keep, PostGlobalUpdate: ( string, (GlobalUpdates) → nil ) → Promise&lt;void&gt; } Stores are used to load and save Keeps from a DataStoreService:GetDataStore()  "},{"title":"UnReleasedActions​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#UnReleasedActions","content":"&lt;/&gt; type UnReleasedActions = { Ignore: string, Cancel: string }   "},{"title":"UnReleasedHandler​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#UnReleasedHandler","content":"&lt;/&gt; type UnReleasedHandler = (Keep.ActiveSession) → UnReleasedActions Used to determine how to handle an session locked Keep Default: &quot;Ignore&quot; Ignores the locked Keep and steals the lock, releasing the previous session &quot;Cancel&quot; Cancels the load of the Keep "},{"title":"Properties​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#properties","content":" "},{"title":"Wrapper​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#Wrapper","content":"&lt;/&gt; Store.Wrapper: {} Wrapper functions that are inheritted by Keeps when they are loaded info Any wrapper changes post .GetStore will not apply to that store but the next one. "},{"title":"Functions​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#functions","content":" "},{"title":"GetStore​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#GetStore","content":"&lt;/&gt; Store.GetStore( storeInfo: StoreInfo | string, dataTemplate: any ) → Promise&lt;Store&gt; Loads a store from a DataStoreService:GetDataStore() and returns a Store object local keepStore = DataKeep.GetStore(&quot;TestStore&quot;, { Test = &quot;Hello World!&quot;, }):awaitValue()   "},{"title":"LoadKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#LoadKeep","content":"&lt;/&gt; Store:LoadKeep( key: string, unReleasedHandler: UnReleasedHandler? ) → Promise&lt;Keep&gt; Loads a Keep from the store and returns a Keep object keepStore:LoadKeep(&quot;Player_&quot; .. player.UserId, function() return &quot;Ignore&quot; end)):andThen(function(keep) print(&quot;Loaded Keep!&quot;) end) info Stores can be loaded multiple times as they are cached, that way you can call :LoadKeep() and get the same cached Keeps  "},{"title":"ViewKeep​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#ViewKeep","content":"&lt;/&gt; Store:ViewKeep( key: string, version: string? ) → Promise&lt;Keep?&gt; Loads a Keep from the store and returns a Keep object, but doesn't save it View only Keeps have the same functions as normal Keeps, but can not operate on data keepStore:ViewKeep(&quot;Player_&quot; .. player.UserId):andThen(function(viewOnlyKeep) print(`Viewing {viewOnlyKeep:Identify()}`) end)   "},{"title":"PostGlobalUpdate​","type":1,"pageTitle":"Store","url":"/DataKeep/api/Store#PostGlobalUpdate","content":"&lt;/&gt; Store:PostGlobalUpdate( key: string, updateHandler: (GlobalUpdates) → nil ) → Promise&lt;void&gt; Posts a global update to a Keep updateHandler reveals globalUpdates to the API keepStore:PostGlobalUpdate(&quot;Player_&quot; .. player.UserId, function(globalUpdates) globalUpdates:AddGlobalUpdate({ Hello = &quot;World!&quot;, }):andThen(function(updateId) print(&quot;Added Global Update!&quot;) end) end)  "},{"title":"WriteLib","type":0,"sectionRef":"#","url":"/DataKeep/docs/WriteLib","content":"","keywords":""},{"title":"Defining a WriteLib​","type":1,"pageTitle":"WriteLib","url":"/DataKeep/docs/WriteLib#defining-a-writelib","content":"-- WriteLib.lua (stored anywheres you can access) return { AddCoins = function(keep, amount) keep.Data.Coins += amount end, RemoveCoins = function(keep, amount) keep.Data.Coins -= amount end, } -- main.lua DataKeep.WriteLib = require(path_to_WriteLib) local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, defaultData):awaitValue() keepStore:LoadKeep(&quot;Player_&quot; .. player.UserId):andThen(function(keep) keep:AddCoins(100) keep:RemoveCoins(50) end)  "},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/DataKeep/docs/Usage","content":"Basic Usage DataKeep will lift everything, the only thing you need to do is load data. DataKeep does not use getter/setter functions allowing for customizable experience like, make your own wrapper. The following is a very basic Keep loader implementation. local Players = game:GetService(&quot;Players&quot;) local DataKeep = require(path_to_datakeep) local defaultData = { Coins = 0, } local loadedKeeps = {} local keepStore = DataKeep.GetStore(&quot;PlayerData&quot;, defaultData) -- generally you can just :awaitValue() I just want to showcase Promises to those unfamiliar local function onPlayerJoin(player) keepStore:LoadKeep(&quot;Player_&quot; .. player.UserId):andThen(function(keep) if keep == nil then player:Kick(&quot;Data locked&quot;) -- will never happen, when no releaseHandler is passed it default steals from the locked session end keep:Reconcile() keep:AddUserId(player.UserId) -- help with GDPR requests keep.OnRelease:Connect(function() -- don't have to clean up, it cleans up internally. player:Kick(&quot;Session Release&quot;) end) if not player:IsDescendantOf(Players) then keep:Release() return end print(`Loaded {player.Name}'s Keep!`) loadedKeeps[player] = keep local leaderstats = Instance.new(&quot;Folder&quot;) leaderstats.Name = &quot;leaderstats&quot; local coins = Instance.new(&quot;NumberValue&quot;) coins.Name = &quot;Coins&quot; coins.Value = keep.Data.Coins leaderstats.Parent = player end) end Players.PlayerRemoving:Connect(function(player) local keep = loadedKeeps[player] if not keep then return end keep:Release() end) keepStore:andThen(function(store) keepStore = store Players.PlayerAdded:Connect(onPlayerJoin) end) Class Approach For more experienced developers I personally opt in to create a service that returns a &quot;Player&quot; OOP class that holds it own cleaner and a Keep inside.","keywords":""},{"title":"Keep","type":0,"sectionRef":"#","url":"/DataKeep/api/Keep","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#types","content":" "},{"title":"ActiveSession​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#ActiveSession","content":"&lt;/&gt; type ActiveSession = { PlaceID: number, JobID: number }   "},{"title":"MetaData​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#MetaData","content":"&lt;/&gt; type MetaData = { ActiveSession: ActiveSession | nil, ForceLoad: ActiveSession | nil, LastUpdate: number, Created: number, LoadCount: number }   "},{"title":"GlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalUpdates","content":"&lt;/&gt; type GlobalUpdates = { ID: number, Updates: {[number]: GlobalUpdate} }   "},{"title":"Keep​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Keep","content":"&lt;/&gt; type Keep = { Data: {}, MetaData: MetaData, GlobalUpdates: GlobalUpdates, UserIds: {}, OnGlobalUpdate: Signal&lt;GlobalUpdate&amp;number&gt;, GlobalStateProcessor: ( update: GlobalUpdate, lock: () → boolean, remove: () → boolean ) → void, OnRelease: Signal }   "},{"title":"Iterator​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Iterator","content":"&lt;/&gt; interface Iterator { Current: () → version?-- Returns the current version, nil if none Next: () → version?-- Returns the next version, nil if none Previous: () → version?-- Returns the previous version, nil if none PageUp: () → void-- Goes to the next page of versions PageDown: () → void-- Goes to the previous page of versions SkipEnd: () → void-- Goes to the last page of versions SkipStart: () → void-- Goes to the first page of versions }  "},{"title":"Properties​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#properties","content":" "},{"title":"GlobalStateProcessor​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GlobalStateProcessor","content":"&lt;/&gt; Keep.GlobalStateProcessor: ( updateData: GlobalUpdate, lock: () → boolean, remove: () → boolean ) → void Define how to process global updates, by default just locks the global update (this is only ran if the keep is online) The function reveals the lock and remove global update function through the parameters. caution Updates must be locked eventually in order for OnGlobalUpdate to get fired warning The lock and remove function revealed here are NOT the same as the ones in the Keep class, they are only for this function.  "},{"title":"OnGlobalUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#OnGlobalUpdate","content":"&lt;/&gt; Keep.OnGlobalUpdate: Signal&lt;( updateData: {}, updateId: number )&gt; Fired when a new global update is locked and ready to be processed caution ONLY locked globals are fired  "},{"title":"OnRelease​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#OnRelease","content":"&lt;/&gt; Keep.OnRelease: Signal&lt;()&gt; Fired when the keep is released (fires before internally released, but after session release) "},{"title":"Functions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#functions","content":" "},{"title":"Save​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Save","content":"&lt;/&gt; Keep:Save() → KeepStruct Manually Saves a keep and returns the data from UpdateAsync() Commonly useful for speeding up global updates caution RESETS AUTO SAVE TIMER ON THE KEEP  "},{"title":"IsActive​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#IsActive","content":"&lt;/&gt; Keep:IsActive() → {boolean} Returns if the Keep is active in the session (not locked by another server)  "},{"title":"Identify​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Identify","content":"&lt;/&gt; Keep:Identify() → string Returns the string identifier for the Keep  "},{"title":"GetKeyInfo​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetKeyInfo","content":"&lt;/&gt; Keep:GetKeyInfo() → DataStoreKeyInfo  Returns the DataStoreKeyInfo for the Keep  "},{"title":"Release​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Release","content":"&lt;/&gt; Keep:Release() → Promise&lt;Keep&gt; Releases the session lock to allow other servers to access the Keep warning This is called before internal release, but after session release, no edits can be made after this point  "},{"title":"Reconcile​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#Reconcile","content":"&lt;/&gt; Keep:Reconcile() → void Fills in any missing data in the Keep, using the data template  "},{"title":"AddUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#AddUserId","content":"&lt;/&gt; Keep:AddUserId(userId: number) → () Associates a userId to a datastore to assist with GDPR requests (The right to erasure)  "},{"title":"RemoveUserId​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#RemoveUserId","content":"&lt;/&gt; Keep:RemoveUserId(userId: number) → () Unassociates a userId to a datastore  "},{"title":"GetVersions​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetVersions","content":"&lt;/&gt; Keep:GetVersions( minDate?: number, maxDate?: number ) → Promise&lt;Iterator&gt; Grabs past versions of the Keep and returns an iterator to customize how to handle the versions &quot;I lost my progress! Last time I had 200 gems!&quot; keep:GetVersions():andThen(function(iterator) local version = iterator.Current() while version do local data = keepStore:ViewKeep(player.UserId, version.Version).Data if data.Gems &gt;= 200 then print(&quot;Found the version with 200 gems!&quot;) break end version = iterator.Next() end end)   "},{"title":"SetVersion​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#SetVersion","content":"&lt;/&gt; Keep:SetVersion( version: string, migrateProcessor?: (versionKeep: Keep) → Keep ) → Promise&lt;Keep&gt; Allows for a manual versioning process, where the version is set and the data is migrated to the new version using the optional migrateProcessor function DataKeep provides a version list iterator. See GetVersions Returns a Promise that resolves to the old keep (before the migration) This is the last time the old keep's GlobalUpdates will be accessible before permanently being removed warning Will not save until the next loop unless otherwise called using :Save or :Overwrite for ViewOnly Keeps caution Any global updates not taken care of in migrateProcessor will be lost  "},{"title":"GetActiveGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetActiveGlobalUpdates","content":"&lt;/&gt; Keep:GetActiveGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of active global updates (not locked/processed)  "},{"title":"GetLockedGlobalUpdates​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#GetLockedGlobalUpdates","content":"&lt;/&gt; Keep:GetLockedGlobalUpdates() → {Array&lt;{ Data: {}, ID: number }&gt;} Returns an array of locked global updates (processed) caution Lock updates can not be changed, only cleared after done being used.  "},{"title":"ClearLockedUpdate​","type":1,"pageTitle":"Keep","url":"/DataKeep/api/Keep#ClearLockedUpdate","content":"&lt;/&gt; Keep:ClearLockedUpdate(id: {number}) → Promise&lt;void&gt; Clears a locked global update after being used warning Passing an active global update id will throw an error &amp; reject the Promise. "}]